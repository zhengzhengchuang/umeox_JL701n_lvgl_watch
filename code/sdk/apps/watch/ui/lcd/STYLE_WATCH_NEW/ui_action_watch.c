#include "app_config.h"
#include "ui/ui_style.h"
#include "ui/ui.h"
#include "ui/ui_api.h"
#include "app_task.h"
#include "system/timer.h"
#include "device/device.h"
#include "key_event_deal.h"
#include "res/resfile.h"
#include "ui/res_config.h"
#include "ui/ui_resource.h"
#include "font/language_list.h"
#include "sport/sport_api.h"
#include "ui/ui_measure.h"
#include "ui/ui_sys_param.h"
#include "btstack/avctp_user.h"
#include "message_vm_cfg.h"
#include "asm/math_fast_function.h"
#include "font/font_textout.h"
#include "ui/result_pic_index.h"
#include "ui/result_str_index.h"
#include "asm/imb.h"
#include "ui/ui_effect.h"

#if TCFG_UI_ENABLE && (!TCFG_LUA_ENABLE)
#ifdef CONFIG_UI_STYLE_JL_ENABLE

#define STYLE_NAME  JL

REGISTER_UI_STYLE(STYLE_NAME)

#define OLDER_STYLE (1)

static u16 watch_num_blue_timer = 0;
static u16 watch_num_green_timer = 0;
static u16 watch_num_red_timer = 0;
static u16 watch_progress_sleep_timer = 0;
static u16 watch_sleep_analysis_timer = 0;
static u16 watch_timer = 0;
static u16 watch_num_test_timer = 0;
static u16 watch_num_1_timer = 0;
static u16 watch_num_2_timer = 0;
static u16 watch_num_3_timer = 0;
static u16 watch_bt_compass_timer = 0;


extern void __set_bt_esco_by_watch(bool flag);
extern void put_float(double fv);

void ui_page_list_init()
{
    ui_page_init();
    ui_page_add(PAGE_0);
    ui_page_add(PAGE_7);
    ui_page_add(PAGE_4);
    ui_page_add(PAGE_37);
    ui_page_add(PAGE_73);

    ui_page_list_all();
}

int ui_core_get_rtc_time(struct ui_time *time)
{
    struct sys_time sys_time = {0};
    void *fd = dev_open("rtc", NULL);
    if (!fd) {
        memset(time, 0, sizeof(*time));
        return -1;
    }
    dev_ioctl(fd, IOCTL_GET_SYS_TIME, (u32)&sys_time);
    time->year  =  sys_time.year;
    time->month = sys_time.month;
    time->day   = sys_time.day;
    time->hour  = sys_time.hour;
    time->min   = sys_time.min;
    time->sec   = sys_time.sec;
    /* g_printf("get_sys_time : %d-%d-%d,%d:%d:%d\n", time->year, time->month, time->day, time->hour, time->min, time->sec); */
    dev_close(fd);
    return 0;
}

#if OLDER_STYLE

struct progress_sleep_priv {
    int hour;
    int min;
    int sec;
    int target_hour;
};

struct progress_sleep_priv progress_sleep = {
    .target_hour = 8,
};

struct progress_record_priv {
    int steps;
    int target_steps;
    int min;
    int target_min;
    int times;
    int target_times;
};

struct progress_record_priv progress_record = {
    .target_steps = 1000,
    .target_min = 30,
    .target_times = 12,
};

int motion_module_get_steps(void);
static void NUM_BLUE_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_blue_timer) {
        return ;
    }
    ui_io_set(IO_FRAME, HIGH);

    this->steps++;
    if (this->steps > 1000) {
        this->steps = 0;
    }

    n.type = TYPE_NUM;
    n.numbs = 1;
#if   TCFG_GSENSOR_ENABLE
    n.number[0] = motion_module_get_steps();
#else
    n.number[0] = this->steps;
#endif
    ui_number_update_by_id(NUM_BLUE, &n);
    percent = this->steps * 100 / this->target_steps;
    if (last_percent != percent) {
        ui_multiprogress_set_persent_by_id(MULTI_PROGRESS, percent);
        last_percent = percent;
    }

    ui_io_set(IO_FRAME, LOW);
}





static int NUM_BLUE_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.steps = 0;
        number->nums = 1;

#if   TCFG_GSENSOR_ENABLE
        number->number[0] = motion_module_get_steps();
#else
        number->number[0] = progress_record.steps;
#endif

        if (!watch_num_blue_timer) {
            watch_num_blue_timer = sys_timer_add(&progress_record, NUM_BLUE_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_blue_timer) {
            sys_timer_del(watch_num_blue_timer);
            watch_num_blue_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_BLUE)
.onchange = NUM_BLUE_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
//-----------------//

static void NUM_GREEN_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_green_timer) {
        return ;
    }
    ui_io_set(IO_FRAME, HIGH);

    this->min++;
    if (this->min > 30) {
        this->min = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = this->min;
    ui_number_update_by_id(NUM_GREEN_1, &n);
    n.number[0] = this->target_min;
    ui_number_update_by_id(NUM_GREEN_2, &n);
    percent = this->min * 100 / this->target_min;
    if (last_percent != percent) {
        ui_multiprogress_set_second_persent_by_id(MULTI_PROGRESS, percent);
        last_percent = percent;
    }

    ui_io_set(IO_FRAME, LOW);
}

static int NUM_GREEN_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.min = 0;
        progress_record.target_min = 30;
        number->nums = 2;
        number->number[0] = progress_record.min;
        number->number[1] = progress_record.target_min;
        if (!watch_num_green_timer) {
            watch_num_green_timer = sys_timer_add(&progress_record, NUM_GREEN_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_green_timer) {
            sys_timer_del(watch_num_green_timer);
            watch_num_green_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_GREEN_1)
.onchange = NUM_GREEN_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

static void NUM_RED_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_red_timer) {
        return;
    }
    ui_io_set(IO_FRAME, HIGH);

    this->times++;
    if (this->times > 12) {
        this->times = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = this->times;
    ui_number_update_by_id(NUM_RED_1, &n);
    n.number[0] = this->target_times;
    ui_number_update_by_id(NUM_RED_2, &n);

    percent = this->times * 100 / this->target_times;
    if (last_percent != percent) {
        ui_multiprogress_set_third_persent_by_id(MULTI_PROGRESS, percent);
        last_percent = percent;
    }

    ui_io_set(IO_FRAME, LOW);
}

static int NUM_RED_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;
    static int timer = 0;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.times = 0;
        progress_record.target_times = 12;
        number->nums = 2;
        number->number[0] = progress_record.times;
        number->number[1] = progress_record.target_times;
        if (!watch_num_red_timer) {
            watch_num_red_timer = sys_timer_add(&progress_record, NUM_RED_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_red_timer) {
            sys_timer_del(watch_num_red_timer);
            watch_num_red_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_RED_1)
.onchange = NUM_RED_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static int TARGET_NUM_HOUR_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        number->nums = 1;
        number->number[0] = progress_sleep.target_hour;
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(TARGET_SLEEP_HOUR)
.onchange = TARGET_NUM_HOUR_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif


static void PROGRESS_SLEEP_timer(void *priv)
{
    if (!watch_progress_sleep_timer) {
        return ;
    }

#if OLDER_STYLE
    static int last_hour = 0;
    static int last_min = 0;
    static int last_percent = 0;
    int percent = 0;
    struct progress_sleep_priv *this = (struct progress_sleep_priv *)priv;

    /* if (++this->sec >= 60) { */
    /* this->sec = 0; */
    /* if (++this->min >= 60) { */
    /* this->min = 0; */
    /* if (++this->hour >= 12) { */
    /* this->hour = 0; */
    /* } */
    /* } */
    /* } */

    //test
    this->min += 10;
    if (this->min >= 60) {
        this->min = 0;
        this->hour++;
        /* if (this->hour >= 8) { */
        /* this->hour = 0; */
        /* } */
    }

    if ((this->hour == 8) && (this->min == 10)) {
        this->hour = 0;
        this->min = 0;
    }

    if (last_hour != this->hour) {
        struct unumber numb_hour;
        numb_hour.type = TYPE_NUM;
        numb_hour.numbs = 1;
        numb_hour.number[0] = this->hour;
        ui_number_update_by_id(SLEEP_HOUR, &numb_hour);

        last_hour = this->hour;
    }

    if (last_min != this->min) {
        struct unumber numb_min;
        numb_min.type = TYPE_NUM;
        numb_min.numbs = 1;
        numb_min.number[0] = this->min;
        ui_number_update_by_id(SLEEP_MIN, &numb_min);

        last_min = this->min;
    }

    percent = (this->hour * 3600 + this->min * 60 + this->sec) / (8 * 36);
    if (last_percent != percent) {
        ui_io_set(IO_FRAME, HIGH);
        ui_progress_set_persent_by_id(PROGRESS_SLEEP, percent);
        ui_io_set(IO_FRAME, LOW);
        last_percent = percent;
    }
#else

    ui_update_source_by_elm(priv, 1);

#endif
}


static int PROGRESS_SLEEP_onchange(void *ctr, enum element_change_event e, void *arg)
{
    int index;
    struct ui_progress *progress = (struct ui_progress *)ctr;

    switch (e) {
    case ON_CHANGE_INIT:
#if OLDER_STYLE
        progress_sleep.hour = 0;
        progress_sleep.min = 0;
        progress_sleep.sec = 0;
        if (!watch_progress_sleep_timer) {
            watch_progress_sleep_timer = sys_timer_add(&progress_sleep, PROGRESS_SLEEP_timer, 1000);
        }
#else
        if (!watch_progress_sleep_timer) {
            watch_progress_sleep_timer = sys_timer_add(ctr, PROGRESS_SLEEP_timer, 1000);
        }
#endif
        break;
    case ON_CHANGE_RELEASE:
        if (watch_progress_sleep_timer) {
            sys_timer_del(watch_progress_sleep_timer);
            watch_progress_sleep_timer = 0;
        }
        break;
    case ON_CHANGE_FIRST_SHOW:
#if (!OLDER_STYLE)
        ui_update_source_by_elm(ctr, 0);
#endif
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(PROGRESS_SLEEP)
.onchange = PROGRESS_SLEEP_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
void refresh_sleep_analysis(void *priv)
{
    if (!watch_sleep_analysis_timer) {
        return ;
    }
    watch_sleep_analysis_timer = 0;
    printf("%s", __func__);
#if 1
    struct unumber deep_score;
    deep_score.type = TYPE_NUM;
    deep_score.numbs = 1;
    deep_score.number[0] = 65;
    ui_number_update_by_id(DEEP_SLEEP_SCORE_NUM, &deep_score);
    struct unumber shallow_score;
    shallow_score.type = TYPE_NUM;
    shallow_score.numbs = 1;
    shallow_score.number[0] = 35;
    ui_number_update_by_id(SHALLOW_SLEEP_SCORE_NUM, &shallow_score);
    struct unumber rem_score;
    rem_score.type = TYPE_NUM;
    rem_score.numbs = 1;
    rem_score.number[0] = 5;
    ui_number_update_by_id(REM_SLEEP_SCORE_NUM, &rem_score);

    struct unumber all_score;
    all_score.type = TYPE_NUM;
    all_score.numbs = 1;
    all_score.number[0] = 60;
    ui_number_update_by_id(ALL_SLEEP_SCORE_NUM, &all_score);

    struct unumber continue_score;
    continue_score.type = TYPE_NUM;
    continue_score.numbs = 1;
    continue_score.number[0] = 80;
    ui_number_update_by_id(SLEEP_CONTINUE_SCORE_NUM, &continue_score);
    if (deep_score.number[0] > 60) {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 3);
    } else if (deep_score.number[0] < 20) {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 1);
    } else {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 2);
    }

    if (shallow_score.number[0] < 55) {
        ui_text_show_index_by_id(SHALLOW_SLEEP_TEXT, 2);
    } else {
        ui_text_show_index_by_id(SHALLOW_SLEEP_TEXT, 3);
    }

    if (rem_score.number[0] > 30) {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 3);
    } else if (rem_score.number[0] < 10) {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 1);
    } else {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 2);
    }



#else


#endif
}

static int SLEEP_ANALYSIS_onchange(void *ctr, enum element_change_event e, void *arg)
{

    switch (e) {
    case ON_CHANGE_INIT:
        if (!watch_sleep_analysis_timer) {
            watch_sleep_analysis_timer = sys_timeout_add(NULL, refresh_sleep_analysis, 10);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_sleep_analysis_timer) {
            sys_timeout_del(watch_sleep_analysis_timer);
            watch_sleep_analysis_timer = 0;
        }
        break;
    case ON_CHANGE_FIRST_SHOW:

        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(SLEEP_ANALYSIS_LAYOUT)
.onchange = SLEEP_ANALYSIS_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};




#if (!OLDER_STYLE)

REGISTER_UI_EVENT_HANDLER(MULTI_PROGRESS)
.onchange = PROGRESS_SLEEP_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif


static void get_sys_time(struct sys_time *time)
{
    void *fd = dev_open("rtc", NULL);
    if (!fd) {
        memset(time, 0, sizeof(*time));
        return;
    }
    dev_ioctl(fd, IOCTL_GET_SYS_TIME, (u32)time);
    /* printf("get_sys_time : %d-%d-%d,%d:%d:%d\n", time->year, time->month, time->day, time->hour, time->min, time->sec); */
    dev_close(fd);
}

#if 0
int ui_get_child_by_id(int id);
static void WATCH_timer(void *priv)
{
    if (!watch_timer) {
        return ;
    }
    struct watch_priv *this = (struct watch_priv *)priv;
    struct sys_time time;
    int id;

    get_sys_time(&time);
    //printf("%04d-%02d-%02d %02d:%02d:%02d\n",time.year,time.month,time.day,time.hour,time.min,time.sec);
    this->hour = time.hour % 12;
    this->min  = time.min;
    this->sec  = time.sec;
    ui_watch_set_time_by_id(STYLE_WATCH_ID(WATCH), this->hour, this->min, this->sec);

    id = STYLE_WATCH_ID(WATCH);
    printf("root id = 0x%x\n", id);
    ui_get_child_by_id(id);
}


static int WATCH_onchange(void *ctr, enum element_change_event e, void *arg)
{
    int index;
    struct ui_watch *watch = (struct ui_watch *)ctr;
    struct sys_time time;

    switch (e) {
    case ON_CHANGE_INIT:
        get_sys_time(&time);
        watch->hour = time.hour % 12;
        watch->min  = time.min;
        watch->sec  = time.sec;
        if (!watch_timer) {
            watch_timer = sys_timer_add(&watch_t, WATCH_timer, 200);
        }
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        if (watch_timer) {
            sys_timer_del(watch_timer);
            watch_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_DIAL_UI_EVENT_HANDLER(WATCH)
.onchange = WATCH_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif





void ui_send_event(u16 event, u32 val)
{
    struct sys_event e;
    e.type = SYS_UI_EVENT;
    e.u.key.event = event;
    e.u.key.value = val;
    sys_event_notify(&e);
}

static int test_handler(const char *type, u32 arg)
{
    printf("msg test %s %s %d \n", __FUNCTION__, type, arg);
    return 0;
}


static const struct uimsg_handl ui_msg_handler[] = {
    { "test1",        test_handler     }, /* 设置音量 */
    { "test2",        test_handler     }, /* 设置音量 */
    { "test3",        test_handler     }, /* 设置音量 */
    { "test4",        test_handler     }, /* 设置音量 */
    { NULL, NULL},      /* 必须以此结尾！ */
};

static int PAGE_mode_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct window *window = (struct window *)ctr;
    printf("window call = %s id =%x \n", __FUNCTION__, window->elm.id);
    switch (e) {
    case ON_CHANGE_INIT:
        ui_register_msg_handler(window->elm.id, ui_msg_handler);//注册消息交互的回调
        break;
    case ON_CHANGE_RELEASE:

        break;
    default:
        return false;
    }
    return false;
}
#if 0
REGISTER_DIAL_UI_EVENT_HANDLER(PAGE_0)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif

REGISTER_UI_EVENT_HANDLER(PAGE_0)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

REGISTER_UI_EVENT_HANDLER(PAGE_1)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

REGISTER_UI_EVENT_HANDLER(PAGE_2)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

REGISTER_UI_EVENT_HANDLER(PAGE_3)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


struct dial_info {
    char number[32];
    int index;
};
struct dial_info dial_info_t = {0};


static void dial_add_number(char ch)
{
    static struct unumber n;

    if (dial_info_t.index >= 19) {
        return;
    }
    dial_info_t.number[dial_info_t.index++] = ch;
    dial_info_t.number[dial_info_t.index] = '\0';
    n.type = TYPE_STRING;
    n.num_str = (u8 *)dial_info_t.number;
    /* g_printf("%s",n.num_str); */
    ui_number_update_by_id(DIAL_NUM, &n);
}

static void dial_remove_number()
{
    static struct unumber n;

    if (dial_info_t.index <= 0) {
        return;
    }
    dial_info_t.number[--dial_info_t.index] = '\0';
    n.type = TYPE_STRING;
    n.num_str = (u8 *)dial_info_t.number;
    /* r_printf("%s",n.num_str); */
    ui_number_update_by_id(DIAL_NUM, &n);
}

static int DIAL_Common_ontouch(void *ctrl, struct element_touch_event *e)
{
    struct element *elm = (struct element *)ctrl;

    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        switch (elm->id) {
        case DIAL_EXIT:
            printf("[5]DIAL_EXIT DOWN\n");
            break;
        case DIAL_DEL:
            printf("[5]DIAL_DEL DOWN\n");
            break;
        case DIAL_0:
            printf("[5]DIAL_0 DOWN\n");
            break;
        case DIAL_1:
            printf("[5]DIAL_1 DOWN\n");
            break;
        case DIAL_2:
            printf("[5]DIAL_2 DOWN\n");
            break;
        case DIAL_3:
            printf("[5]DIAL_3 DOWN\n");
            break;
        case DIAL_4:
            printf("[5]DIAL_4 DOWN\n");
            break;
        case DIAL_5:
            printf("[5]DIAL_5 DOWN\n");
            break;
        case DIAL_6:
            printf("[5]DIAL_6 DOWN\n");
            break;
        case DIAL_7:
            printf("[5]DIAL_7 DOWN\n");
            break;
        case DIAL_8:
            printf("[5]DIAL_8 DOWN\n");
            break;
        case DIAL_9:
            printf("[5]DIAL_9 DOWN\n");
            break;
        case DIAL_CTL:
            printf("[5]DIAL_CTL DOWN\n");
            break;
        case DIAL_CALL:
            printf("[5]DIAL_CALL DOWN\n");
            break;
        default:
            break;
        }
        /* ui_core_highlight_element(elm, true); */
        ui_core_redraw(elm);
        return true;
    case ELM_EVENT_TOUCH_UP:
        switch (elm->id) {
        case DIAL_EXIT:
            printf("[5]DIAL_EXIT UP\n");
            dial_add_number('*');
            break;
        case DIAL_DEL:
            printf("[5]DIAL_DEL UP\n");
            dial_remove_number();
            break;
        case DIAL_0:
            printf("[5]DIAL_0 UP\n");
            dial_add_number('0');
            break;
        case DIAL_1:
            printf("[5]DIAL_1 UP\n");
            dial_add_number('1');
            break;
        case DIAL_2:
            printf("[5]DIAL_2 UP\n");
            dial_add_number('2');
            break;
        case DIAL_3:
            printf("[5]DIAL_3 UP\n");
            dial_add_number('3');
            break;
        case DIAL_4:
            printf("[5]DIAL_4 UP\n");
            dial_add_number('4');
            break;
        case DIAL_5:
            printf("[5]DIAL_5 UP\n");
            dial_add_number('5');
            break;
        case DIAL_6:
            printf("[5]DIAL_6 UP\n");
            dial_add_number('6');
            break;
        case DIAL_7:
            printf("[5]DIAL_7 UP\n");
            dial_add_number('7');
            break;
        case DIAL_8:
            printf("[5]DIAL_8 UP\n");
            dial_add_number('8');
            break;
        case DIAL_9:
            printf("[5]DIAL_9 UP\n");
            dial_add_number('9');
            break;
        case DIAL_CTL:
            printf("[5]DIAL_CTL UP\n");
            dial_add_number(' ');
            break;
        case DIAL_CALL:
            printf("[5]DIAL_CALL UP\n");
            struct phonebook message;
            if (get_bt_connect_status() !=  BT_STATUS_WAITINT_CONN) {
                int len = phonebook_get_name_by_number(dial_info_t.number, message.name);
                if (len == 0) {
                    sprintf(message.name, "%s", "unknow");
                }
                set_call_log_message(1, message.name, message.number, NULL);
                __set_bt_esco_by_watch(1);
                user_send_cmd_prepare(USER_CTRL_DIAL_NUMBER, dial_info_t.index, dial_info_t.number);
            }
            break;
        default:
            break;
        }
        /* ui_core_highlight_element(elm, false); */
        ui_core_redraw(elm);

        break;
    default:
        break;
    }
    return true;
}

REGISTER_UI_EVENT_HANDLER(DIAL_EXIT)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};

REGISTER_UI_EVENT_HANDLER(DIAL_DEL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_0)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_1)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_2)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_3)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_4)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_5)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_6)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_7)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_8)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_9)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_CTL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_CALL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};

static int DIAL_NUM_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        dial_info_t.index = 0;
        dial_info_t.number[dial_info_t.index] = '\0';
        /* ui_number_update(number, dial_info_t.number); */
        number->type = TYPE_STRING;
        number->num_str = (u8 *)dial_info_t.number;
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(DIAL_NUM)
.onchange = DIAL_NUM_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

/*文本控件多字符串组合显示示例*/
static int BASEFORM_238_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    u8 index_buf[3];
    static u16 store_buf[4];

    switch (event) {
    case ON_CHANGE_INIT:
        /* 一二三四五六日 */
        index_buf[0] = 0;//一
        index_buf[1] = 2;//三
        index_buf[2] = 4;//五
        ui_text_set_combine_index(text, store_buf, index_buf, 3);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


/* REGISTER_UI_EVENT_HANDLER(BASEFORM_238) */
/* .onchange = BASEFORM_238_onchange, */
/* .onkey = NULL, */
/* .ontouch = NULL, */
/* }; */

#define MAX_BGP_GRID_ITEM       (10)
static int cur_grid_watch = 0;

extern u32 watch_bgp_get_nums();
extern char *watch_bgp_get_item(u8 sel_item);
extern int watch_bgp_set_related(char *bgp, u8 cur_watch, u8 del);

static int WATCH_BGP_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_grid *grid = (struct ui_grid *)_ctrl;
    int items_num = 0;

    switch (event) {
    case ON_CHANGE_INIT_PROBE:
        items_num = watch_bgp_get_nums() + 1;
        items_num = (items_num >= MAX_BGP_GRID_ITEM) ? MAX_BGP_GRID_ITEM : items_num;
        items_num = (items_num == 0) ? 1 : items_num;

        printf("grid num %d\n", items_num);
        ui_grid_set_item_num(grid, items_num);//修改列表条目数量,不能超过列表的最大数量
        break;
    default:
        break;
    }
    return 0;
}

static int WATCH_BGP_ontouch(void *ctr, struct element_touch_event *e)
{
    struct ui_grid *grid = (struct ui_grid *)ctr;
    static u8 touch_action = 0;
    int sel_item;
    int ret;
    char *bgp = NULL;

    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:

        sel_item = ui_grid_cur_item(grid);
        printf("watch_sel_bgp %d, %d\n", sel_item, touch_action);
        if (touch_action != 1) {
            break;
        }

        if (sel_item > 0) {
            bgp = watch_bgp_get_item(sel_item - 1);
            bgp = &bgp[strlen(RES_PATH)];
        }
        ret = watch_bgp_set_related(bgp, cur_grid_watch, 0);
        if (ret != 0) {
            printf("watch_set_style err %d\n", sel_item);
            break;
        }

        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_16);
        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        break;
    case ELM_EVENT_TOUCH_L_MOVE:
        return true;
    case ELM_EVENT_TOUCH_R_MOVE:
        sel_item = ui_grid_cur_item(grid);
        printf("tem:%d \n", sel_item);
        if (sel_item == 0) { // 在第一项位置右滑默认处理（返回上一页面）
            struct element_css *css;
            css = ui_core_get_element_css(&grid->item[sel_item].elm);
            printf("css:%d,%d,%d,%d \n", css->left, css->top, css->width, css->height);
            if (css->left > 0) {
                break;
            }
        }
        return true;
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(WATCH_HLIST_BGP)
.onchange = WATCH_BGP_onchange,
 .onkey = NULL,
  .ontouch = WATCH_BGP_ontouch,
};
typedef struct bgpfile {
    RESFILE *file;
    struct flash_file_info info;
} BGPFILE;
static int BGP_PREVIEW_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    static BGPFILE bgp_file[MAX_BGP_GRID_ITEM] = {0};
    static u32 open_flag = 0;
    int sel_item;
    char *watch_bgp_item;
    switch (event) {
    case ON_CHANGE_INIT:
        int items_num = 0;
        if (open_flag) {
            break;
        }

        items_num = watch_bgp_get_nums();
        items_num = (items_num >= MAX_BGP_GRID_ITEM) ? MAX_BGP_GRID_ITEM : items_num;
        for (sel_item = 0; sel_item < items_num; sel_item++) {
            watch_bgp_item = watch_bgp_get_item(sel_item);
            if (watch_bgp_item == NULL) {
                printf("prew get item err %d\n", sel_item);
                return FALSE;
            }
            printf("watch_bgp_item:%s", watch_bgp_item);

            bgp_file[sel_item].file = res_fopen(watch_bgp_item, "r");
            if (!bgp_file[sel_item].file) {
                printf("open_bgp_prewfile fail %s\n", watch_bgp_item);
                return FALSE;
            }
            if (ui_res_flash_info_get(&bgp_file[sel_item].info, watch_bgp_item, "res")) {
                printf("get_bgp_file_tab_fail %s \n", watch_bgp_item);
                return false;
            }
            printf("prew out\n");
        }
        open_flag = 1;

        break;
    case ON_CHANGE_SHOW:

        switch (pic->elm.id) {
        case BGP_0:
            sel_item = 0;
            break;
        case BGP_1:
            sel_item = 1;
            break;
        case BGP_2:
            sel_item = 2;
            break;
        case BGP_3:
            sel_item = 3;
            break;
        case BGP_4:
            sel_item = 4;
            break;
        case BGP_5:
            sel_item = 5;
            break;
        case BGP_6:
            sel_item = 6;
            break;
        case BGP_7:
            sel_item = 7;
            break;
        case BGP_8:
            sel_item = 8;
            break;
        default:
            return FALSE;
        }

        if ((sel_item >= watch_bgp_get_nums()) || (bgp_file[sel_item].file == NULL)) {
            printf("select bgp preview err1 %x, %d\n", pic->elm.id, sel_item);
            return FALSE;
        }
        pic->elm.css.background_image = 1;
        dc->preview.file = bgp_file[sel_item].file;
        dc->preview.file_info = &bgp_file[sel_item].info;
        dc->preview.id = 1;
        dc->preview.page = 0;
        break;
    case ON_CHANGE_RELEASE:

        for (sel_item = 0; sel_item < MAX_BGP_GRID_ITEM; sel_item++) {
            if (bgp_file[sel_item].file) {
                res_fclose(bgp_file[sel_item].file);
                ui_res_flash_info_free(&bgp_file[sel_item].info, "res");
                bgp_file[sel_item].file = NULL;
            }
        }
        open_flag = 0;

        break;
    default:
        break;
    }

    return 0;
}

REGISTER_UI_EVENT_HANDLER(BGP_NULL)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_0)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_1)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_2)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_3)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_4)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_5)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_6)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_7)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_8)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};









#define MAX_GRID_ITEM       (6)
extern int watch_set_style(int style);
extern int watch_get_items_num();
extern char *watch_get_item(int style);
extern int watch_version_juge(char *watch_item);
extern int watch_get_style();

//判断是否当前表盘是否支持多功能拓展 由用户进行判断依据
//这里先默认表盘0是支持的
static int IS_watch_support_expand(int style)
{
    if (style == 0) {
        return false;
    } else {
        return false;
    }
}


static int watch_list_children_init(struct ui_grid *grid)
{
    struct element *k;
    if (!grid) {
        return 0;
    }

    for (int i = 0; i < grid->avail_item_num; i++) {
        list_for_each_child_element(k, &grid->item[i].elm) {
            switch (ui_id2type(k->id)) {
            case CTRL_TYPE_TEXT:
                struct ui_text *text = (struct ui_text *)k;
                if (!strcmp(text->source, "expand")) {
                    if (IS_watch_support_expand(i)) {
                        text->elm.css.invisible = 0;
                    } else {
                        text->elm.css.invisible = 1;
                    }
                }
                break;
            }
        }
    }
    return 0;
}


static int WATCH_VERTLIST_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_grid *grid = (struct ui_grid *)_ctrl;
    int items_num = 0;

    switch (event) {
    case ON_CHANGE_INIT_PROBE:
        items_num = watch_get_items_num();
        items_num = (items_num >= MAX_GRID_ITEM) ? MAX_GRID_ITEM : items_num;

        printf("grid num %d\n", items_num);
        ui_grid_set_item_num(grid, items_num);//修改列表条目数量,不能超过列表的最大数量
        break;
    case ON_CHANGE_FIRST_SHOW:
        watch_list_children_init(grid);//初始化一些功能表盘按钮
        break;
    default:
        break;
    }
    return 0;
}

static int WATCH_VERTLIST_ontouch(void *ctr, struct element_touch_event *e)
{
    struct ui_grid *grid = (struct ui_grid *)ctr;
    static u8 touch_action = 0;
    int sel_item;
    int ret;
    /* printf("WATCH_VERTLIST_ontouch:%d \n", e->event); */
    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:

        if (touch_action != 1) {
            break;
        }

        sel_item = ui_grid_cur_item(grid);
        printf("watch_set_style %d\n", sel_item);

        ret = watch_version_juge(watch_get_item(sel_item));
        if (ret != 0) {
            break;
        }

        ret = watch_set_style(sel_item);
        if (ret != true) {
            printf("watch_set_style err %d\n", sel_item);
            break;
        }

        struct rect r;
        struct element *p, *n;
        struct element *elm = &grid->item[sel_item].elm;
        list_for_each_child_element_reverse(p, n, elm) {
            struct ui_text *text = (struct ui_text *)p;
            if (!p->css.invisible && ((ui_id2type(p->id)) == CTRL_TYPE_TEXT) && !strcmp(text->source, "expand")) { //判断是否字符控件以及是否可见
                ui_core_get_element_abs_rect(p, &r);
                if (in_rect(&r, &e->pos)) {
                    printf("<<<<< __FUNCTION__ = %s __LINE__ =%d >>>>>\n", __FUNCTION__, __LINE__);
                    ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_37);
                    return TRUE;
                    break;
                }
            }
        }

        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | DIAL_PAGE_0);

        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        break;
    case ELM_EVENT_TOUCH_L_MOVE:
        return true;
    case ELM_EVENT_TOUCH_R_MOVE:
        sel_item = ui_grid_cur_item(grid);
        printf("tem:%d \n", sel_item);
        if (sel_item == 0) { // 在第一项位置右滑默认处理（返回上一页面）
            struct element_css *css;
            css = ui_core_get_element_css(&grid->item[sel_item].elm);
            printf("css:%d,%d,%d,%d \n", css->left, css->top, css->width, css->height);
            if (css->left > 0) {
                break;
            }
        }
        return true;
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(WATCH_VLIST)
.onchange = WATCH_VERTLIST_onchange,
 .onkey = NULL,
  .ontouch = WATCH_VERTLIST_ontouch,
};

typedef struct viewfile {
    RESFILE *file;
    struct flash_file_info info;
} VIEWFILE;

static int DIAL_PREVIEW_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    /* static FILE *view_file = NULL; */
    /* static FILE *view1_file = NULL; */
    /* static FILE *view2_file = NULL; */
    /* static FILE *view3_file = NULL; */
    /* static FILE *view4_file = NULL; */
    /* static FILE *view5_file = NULL; */
    static VIEWFILE view_file[MAX_GRID_ITEM] = {0};
    static u32 open_flag = 0;
    int sel_item;
    char tmp_name[100];
    char *sty_suffix = ".sty";
    char *view_suffix = ".view";
    char *watch_item;
    u32 tmp_strlen;
    u32 sty_strlen;

    switch (event) {
    case ON_CHANGE_INIT:
        int items_num = 0;
        if (open_flag) {
            break;
        }
        items_num = watch_get_items_num();
        items_num = (items_num >= MAX_GRID_ITEM) ? MAX_GRID_ITEM : items_num;
        sty_strlen = strlen(sty_suffix);
        for (sel_item = 0; sel_item < items_num; sel_item++) {
            watch_item = watch_get_item(sel_item);
            if (watch_item == NULL) {
                printf("prew get item err %d\n", sel_item);
                return FALSE;
            }

            tmp_strlen = strlen(watch_item);
            strcpy(tmp_name, watch_item);
            strcpy(&tmp_name[tmp_strlen - sty_strlen], view_suffix);
            tmp_name[tmp_strlen - sty_strlen + strlen(view_suffix)] = '\0';
            printf("prew name %s\n", tmp_name);
            view_file[sel_item].file = res_fopen(tmp_name, "r");
            if (!view_file[sel_item].file) {
                printf("open_prewfile fail %s\n", tmp_name);
                return FALSE;
            }
            if (ui_res_flash_info_get(&view_file[sel_item].info, tmp_name, "res")) {
                printf("get_prewfile tab fail %s\n", tmp_name);
                return false;
            }
            printf("prew out\n");

        }
        open_flag = 1;

        break;
    case ON_CHANGE_SHOW:
        if (pic->elm.id == DIAL0_PREVIEW) {
            sel_item = 0;

            /* if (!view_file) { */
            /* view_file = res_fopen(RES_PATH"watch/watch.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view_file; */
        } else if (pic->elm.id == DIAL1_PREVIEW) {
            sel_item = 1;

            /* if (!view_file) { */
            /* if (!view1_file) { */
            /* view1_file = res_fopen(RES_PATH"watch1/watch1.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view1_file; */
        } else if (pic->elm.id == DIAL2_PREVIEW) {
            sel_item = 2;

            /* if (!view_file) { */
            /* if (!view2_file) { */
            /* view2_file = res_fopen(RES_PATH"watch2/watch2.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view2_file; */
        } else if (pic->elm.id == DIAL3_PREVIEW) {
            sel_item = 3;

            /* if (!view_file) { */
            /* if (!view3_file) { */
            /* view3_file = res_fopen(RES_PATH"watch3/watch3.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view3_file; */
        } else if (pic->elm.id == DIAL4_PREVIEW) {
            sel_item = 4;

            /* if (!view_file) { */
            /* if (!view4_file) { */
            /* view4_file = res_fopen(RES_PATH"watch4/watch4.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view4_file; */
        } else if (pic->elm.id == DIAL5_PREVIEW) {
            sel_item = 5;

            /* if (!view_file) { */
            /* if (!view5_file) { */
            /* view5_file = res_fopen(RES_PATH"watch5/watch5.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view5_file; */
        } else {
            printf("select preview err0 %x\n", pic->elm.id);
            return FALSE;
        }

        if ((sel_item >= watch_get_items_num()) || (view_file[sel_item].file == NULL)) {
            printf("select preview err1 %x, %d\n", pic->elm.id, sel_item);
            return FALSE;
        }
        pic->elm.css.background_image = 1;
        dc->preview.file = view_file[sel_item].file;
        dc->preview.file_info = &view_file[sel_item].info;
        dc->preview.id = 1;
        dc->preview.page = 0;
        break;
    case ON_CHANGE_RELEASE:

        for (sel_item = 0; sel_item < MAX_GRID_ITEM; sel_item++) {
            if (view_file[sel_item].file) {
                res_fclose(view_file[sel_item].file);
                ui_res_flash_info_free(&view_file[sel_item].info, "res");
                view_file[sel_item].file = NULL;
            }
        }
        open_flag = 0;

        break;
    }

    return 0;
}

REGISTER_UI_EVENT_HANDLER(DIAL0_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL1_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL2_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL3_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL4_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL5_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static int watch_bgp_button_ontouch(void *ctr, struct element_touch_event *e)
{
    struct button *button = (struct button *)ctr;

    /* printf("__FUNCTION__ = %s\n", __FUNCTION__); */
    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:

        break;
    case ELM_EVENT_TOUCH_UP:
        switch (button->elm.id) {
        case DIAL0_BUTTON:
            cur_grid_watch = 0;
            break;
        case DIAL1_BUTTON:
            cur_grid_watch = 1;
            break;
        case DIAL2_BUTTON:
            cur_grid_watch = 2;
            break;
        case DIAL3_BUTTON:
            cur_grid_watch = 3;
            break;
        case DIAL4_BUTTON:
            cur_grid_watch = 4;
            break;
        case DIAL5_BUTTON:
            cur_grid_watch = 5;
            break;
        default:
            return false;
        }
        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_31);
        break;
    default:
        break;
    }
    return false;
}
REGISTER_UI_EVENT_HANDLER(DIAL0_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL1_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL2_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL3_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL4_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL5_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};








static int NewLayout21_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_slider *slider = (struct ui_slider *)_ctrl;
    int i;

    switch (event) {
    case ON_CHANGE_INIT:
        ui_slider_set_persent(slider, 50);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

/* REGISTER_UI_EVENT_HANDLER(NEWLAYOUT_21) */
/* .onchange = NewLayout21_onchange, */
/* .onkey = NULL, */
/* .ontouch = NULL, */
/* }; */


static int startlight_action_page_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct window *window = (struct window *)ctr;
    /* printf("enter startlight action_page = %s id =%x \n", __FUNCTION__, window->elm.id); */

    switch (e) {
    case ON_CHANGE_INIT:
        /* key_ui_takeover(1); */
        break;
    case ON_CHANGE_RELEASE:
        /* key_ui_takeover(0); */
        break;
    default:
        return false;
    }
    return false;
}


static int startlight_action_page_onkey(void *ctr, struct element_key_event *e)
{
    switch (e->value) {
    case KEY_OK:
        printf("skey_ok\n");
        UI_HIDE_CURR_WINDOW();
        UI_SHOW_WINDOW(PAGE_17);
        break;
    case KEY_DOWN:
        break;
    case KEY_UP:
        break;
    default:
        return false;
    }
    return false;
}

REGISTER_UI_EVENT_HANDLER(PAGE_18)
.onchange = startlight_action_page_onchange,
 .onkey = startlight_action_page_onkey,
  .ontouch = NULL,
};


static u32 icon_tstatus = 0;
#if 0
static int startlight_page_ontouch(void *_layout, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)_layout;
    /* static u8 flag = 0; */

    switch (e->event) {

    case ELM_EVENT_TOUCH_UP:
        /* printf("stouch up\n"); */
        /* if (flag == 1) { */
        /* UI_HIDE_CURR_WINDOW(); */
        /* UI_SHOW_WINDOW(PAGE_18); */
        /* } */
        /* flag = 0; */
        break;
    case ELM_EVENT_TOUCH_HOLD:
        /* printf("stouch hold\n"); */
        break;
    case ELM_EVENT_TOUCH_MOVE:
        /* printf("stouch move\n"); */
        /* flag = 2; */
        break;
    case ELM_EVENT_TOUCH_DOWN:
        printf("stouch down\n");
        /* flag = 1; */
        icon_tstatus = 1;
        break;
    /* return true; */
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(BASEFORM_296)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};

REGISTER_UI_EVENT_HANDLER(BASEFORM_297)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_298)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_299)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_300)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_301)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_302)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_303)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_304)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_305)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_306)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_307)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_308)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_309)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_310)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_311)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_312)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_313)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_314)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
#endif




/************************************ startlight begin *************************/

struct icon_list {
    struct list_head entry;
    int index;
    struct element *elm;

    int left;
    int top;
    int right;
    int bottom;

    int css_left;
    int css_top;
    int css_width;
    int css_height;

    int width;
    int height;
    int cx;
    int cy;
    int size;
};

struct scene_info {
    u32 saved;

    //layout info
    int css_left;
    int css_top;
    int css_width;
    int css_height;

    //icon_info
    int center_index;
};


struct icon_size_info {
    u16 icon_w;
    u16 icon_h;
};

struct variable_info {
    u16 init;

    //屏幕的宽和高
    u16 lcd_w;
    u16 lcd_h;

    //两点间距离的经验值，用于判断中心图标和某个图标间的距离属于哪个级别，
    //从而显示哪张尺寸的图片，这个需要调试来获取！！！
    u16 ref_distance;

    //图标的图片数和图标图片的实际宽高，用于分多级来显示
    //目前是4张图片每个图标, 每个图标尺寸一样的
    u16 icon_level;
    struct icon_size_info *ics;
    struct icon_list *icon_core;

};




/**
 * @brief 满天星相关说明
 *
 * 关于布局:
 * 1.第一个图标必须放到布局的中心，如果布局使用扩展并超过屏幕大小，则需要把布局相对屏幕
 * 往左往上移动来达到屏幕显示布局中心部分的目的，例如:屏幕大小454，布局大小700，根据(700-454)/2=123,
 * 那么布局的坐标应该是从(0,0)变成(-123,-123),相应的中心图标的中心点(只是中心点，坐标还
 * 要减去图标半径)从(227,227),变成(350,350)
 * 2.图标间的摆放形状最好按照六边形摆放，视觉效果会好看些,水平放向和垂直方向的图标是相互紧挨着的，如果
 * 使用SVI_USE_SPHERE方式，则水平方向和垂直方向的图标之间的间隔可以适当加大来达到更强烈的3D效果
 *
 * 关于不同尺寸屏幕的代码修改:
 * 1.不使用SVI_USE_SPHERE,那么根据需要修改 IS_CIRCLE_SCREEN,ratio_tab[],startlight_svi_init()
 * 2.使用SVI_USE_SPHERE,根据需要修改startlight_svi_init(),SCREEN_W,SCREEN_H,CX_OFFSET,CY_OFFSET,icon_r,
 * 3.限制滑出的修改, 默认不限制
 *
 * 关于拨码器缩放:
 * 1.test_page_onkey这里控制具体的逻辑
 * 2.icon_step控制缩放的级别，USE_DIFF_ICON为0时，级别缩放的比例是根据svi.ics[s_icon]定义的大小来缩放, 缩放 <= 1.0
 * 3.USE_DIFF_ICON为1时,根据对应的注释在不同屏幕尺寸时可修改ICON_STEP_LIMIT, step_scale_tab,
 * 使用该方式要注意：布局必须足够大，不然当图标放大时,超过图标本身，有可能图标的范围已经不在布局范围内，
 * 导致显示不出来某些图标!!!
 *
 *
 * 关于限制滑出:
 * 1.在ELM_EVENT_TOUCH_MOVE处做处理
 * 2.通过计算虚拟的屏幕左上角0点(假设会动),超过屏幕左上角原点(不会动)的距离,来限制全部滑出,根据需要修改
 * 3.默认不限制
 *
 * @param
 *
 * @return
 */

#define SVI_USE_ARBIRECT	1//方屏:圆角矩形
#define SVI_USE_SPHERE		0//圆屏:球面圆形
#define SVI_USE_NORMAL		0//

LIST_HEAD(icon_root);
#define abs(x)  ((x)>0?(x):-(x) )

static struct scene_info slinfo = {0};
static struct variable_info svi = {0};
static int icon_step = 0;

#if (SVI_USE_NORMAL)

#define IS_CIRCLE_SCREEN		1  //用于判断是圆屏还是方屏

static float ratio_tab[5] = {0.4, 0.5, 0.86, 0.91, 1};//中心区域（非边界区域）的那几级图标变化的大小


//不同屏幕的初始化参数，根据需要调整！！！
static int startlight_svi_init()
{
    if (svi.init) {
        return 0;
    }

    svi.lcd_w = 454;//这里写屏幕的实际大小
    svi.lcd_h = 454;

#if (SVI_USE_NORMAL)
    //用于中心区域图标级别的阈值判断，超过这个阈值则表示第2级，小于表示第1级，
    //中心图标是第0级，不同尺寸的屏幕需要实测调整
    svi.ref_distance = 3500 * 4;
#endif

    /*** 对于使用SVI_USE_SPHERE方式的满天星，svi.ics这部分只用于拨码器缩放 ***/
    svi.icon_level = 5;
    svi.ics = malloc(svi.icon_level * sizeof(struct icon_size_info));
    if (svi.ics == NULL) {
        printf("err malloc ics \n");
        return -1;
    }

    svi.ics[0].icon_w = 45 * 2;
    svi.ics[0].icon_h = 45 * 2;

    svi.ics[1].icon_w = 41 * 2;
    svi.ics[1].icon_h = 41 * 2;

    svi.ics[2].icon_w = 39 * 2;
    svi.ics[2].icon_h = 39 * 2;

    svi.ics[3].icon_w = 22 * 2;
    svi.ics[3].icon_h = 22 * 2;

    svi.ics[4].icon_w = 16 * 2;
    svi.ics[4].icon_h = 16 * 2;

    /******************************************************/


    svi.init = 1;

    return 0;
}


#endif



static int startlight_scene_save(struct layout *layout, struct list_head *root)
{
    slinfo.saved = 0;

#if ((SVI_USE_SPHERE) || (SVI_USE_ARBIRECT))

    slinfo.css_left = layout->elm.css.left;
    slinfo.css_top = layout->elm.css.top;
    slinfo.css_width = layout->elm.css.width;
    slinfo.css_height = layout->elm.css.height;

    slinfo.saved = 1;

#else

    struct icon_list *icon_p;

    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->size == 0) {
            slinfo.center_index = icon_p->index;
            slinfo.saved = 1;
        }
    }

    if (slinfo.saved == 0) {
        printf("scene_info save fail\n");
        return -1;
    }
    slinfo.css_left = layout->elm.css.left;
    slinfo.css_top = layout->elm.css.top;
    slinfo.css_width = layout->elm.css.width;
    slinfo.css_height = layout->elm.css.height;

#endif

    return 0;
}

static int startlight_scene_recover(struct layout *layout, struct list_head *root)
{
    if (slinfo.saved == 0) {
        return -1;
    }

#if (SVI_USE_NORMAL)
    struct icon_list *icon_p;
    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->index == slinfo.center_index) {
            icon_p->size = 0;
        }
    }
#endif

    layout->elm.css.left = slinfo.css_left;
    layout->elm.css.top = slinfo.css_top;
    layout->elm.css.width = slinfo.css_width;
    layout->elm.css.height = slinfo.css_height;

    slinfo.saved = 0;
    return 0;
}


static int16_t fast_atan2(int x, int y)
{
    unsigned char negflag;
    unsigned char tempdegree;
    unsigned char comp;
    unsigned int degree;
    unsigned int ux;
    unsigned int uy;

    negflag = 0;
    if (x < 0) {
        negflag += 0x01;
        x = (0 - x);
    }
    ux = x;
    if (y < 0) {
        negflag += 0x02;
        y = (0 - y);
    }
    uy = y;

    if (ux > uy) {
        degree = (uy * 45) / ux;
        negflag += 0x10;
    } else {
        degree = (ux * 45) / uy;
    }

    comp = 0;
    tempdegree = degree;
    if (tempdegree > 22) {
        if (tempdegree <= 44) {
            comp++;
        }
        if (tempdegree <= 41) {
            comp++;
        }
        if (tempdegree <= 37) {
            comp++;
        }
        if (tempdegree <= 32) {
            comp++;
        }
    } else {
        if (tempdegree >= 2) {
            comp++;
        }
        if (tempdegree >= 6) {
            comp++;
        }
        if (tempdegree >= 10) {
            comp++;
        }
        if (tempdegree >= 15) {
            comp++;
        }
    }
    degree += comp;

    if (negflag & 0x10) {
        degree = (90 - degree);
    }

    if (negflag & 0x02) {
        if (negflag & 0x01) {
            degree = (180 + degree);
        } else {
            degree = (180 - degree);
        }
    } else {
        if (negflag & 0x01) {
            degree = (360 - degree);
        }
    }
    return degree;
}
static inline int get_angle(int angx, int angy)
{
    return (int)(fast_atan2(angy, angx));
}


#if (SVI_USE_NORMAL)

int icon_change(struct list_head *root, struct element *elm, int draw)
{
    struct icon_list *icon_p = NULL;
    struct icon_list *n = NULL;
    struct rect rect;

    int center_x;
    int center_y;
    int center_change;
    int center_index;

    int s_icon, p_icon;
    struct element elm_tmp;
    struct element *elm_p;
    struct element *layout_elm = elm;
    int cx, cy;
    int xoffset, yoffset;
    float ratio;
    int limit = svi.icon_level - 1;
    struct icon_list *icon_core = svi.icon_core;
    u32 radius = svi.lcd_w / 2;
    int r0 = 0;
    float r1;
    float d0;
    int disx, disy;
    float tx, ty;
    int angle;
    struct rect layout_rect;
    int icon_core_ori_cx, icon_core_ori_cy;
    int icon_core_cx, icon_core_cy;
    struct rect cur_rect, icon_core_rect;
    struct element elm_mix;
    int comp0, comp1, comp2;

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);
    /* printf("\n\nlay %d, %d, %d, %d\n\n", layout_rect.left, layout_rect.top, layout_rect.width, layout_rect.height); */

    center_index = -1;
    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->size) {
            icon_p->size = -1;
        } else {
            icon_p->size = -1;
            center_index = icon_p->index;
        }
    }

    center_change = false;
    list_for_each_entry(icon_p, root, entry) {
        /* struct element elm; */
        /* memcpy(&elm, icon_p->elm, sizeof(struct element)); */

        elm_tmp.parent = icon_p->elm->parent;
        elm_tmp.css.left = icon_p->css_left;
        elm_tmp.css.top = icon_p->css_top;
        elm_tmp.css.width = icon_p->css_width;
        elm_tmp.css.height = icon_p->css_height;

        ui_core_get_element_abs_rect(&elm_tmp, &rect);
        if ((rect.left < (svi.lcd_w / 2)) &&
            ((rect.left + rect.width) > (svi.lcd_w / 2)) &&
            (rect.top < (svi.lcd_h / 2)) &&
            ((rect.top + rect.height) > (svi.lcd_h / 2))) {
            /* icon_p->size = 0;  */
            center_change = true;
            break;
        }
    }

    if (!center_change) {
        if (center_index != (-1)) {
            list_for_each_entry(icon_p, root, entry) {
                if (icon_p->index == center_index) {
                    icon_p->size = 0;//记录中心图标的圆心位置 */
                    center_x = icon_p->cx;
                    center_y = icon_p->cy;
                    break;
                }
            }
#if IS_CIRCLE_SCREEN
            //圆屏
            elm_tmp.parent = icon_p->elm->parent;
            elm_tmp.css.left = icon_p->css_left;
            elm_tmp.css.top = icon_p->css_top;
            elm_tmp.css.width = icon_p->css_width;
            elm_tmp.css.height = icon_p->css_height;

            ui_core_get_element_abs_rect(&elm_tmp, &rect);

            r0 = rect.width / 2;
            cx = rect.left + r0;
            cy = rect.top + r0;
            disx = abs(cx - icon_core->cx);
            disy = abs(cy - icon_core->cy);
            d0 = complex_abs_float((float)disx, (float)disy) + r0 + 10;
            if (d0 > radius) {
                return -1;
            }
#endif

        } else {
            if (icon_step == 0) {
                return -1;
            }
        }
    } else {
        icon_p->size = 0; //记录中心图标的圆心位置 */
        center_x = icon_p->cx;
        center_y = icon_p->cy;
        center_index = icon_p->index;
    }

    /* printf("zero index %x\n", icon_p->index); */

    if (icon_p->size != 0) {
        return -1;
    }

    int x0, y0;
    float k;
    float a, b, c;
    float r2;
    int x1, x2, y1, y2;
    u8 overflow = 0;
    struct element *elm_c;
    n = icon_p;

#if IS_CIRCLE_SCREEN //圆屏

__center_overflow:
    if (overflow == 1) {
        elm_c = n->elm;
        elm_c->css.width = n->css_width;
        elm_c->css.height = n->css_height;
        elm_c->css.left = n->css_left + (n->css_width - elm_c->css.width) / 2;
        elm_c->css.top = n->css_top + (n->css_height - elm_c->css.height) / 2;
        elm_c->css.ratio.en = 1;
        elm_c->css.ratio.ratio_w = ratio_tab[limit];
        elm_c->css.ratio.ratio_h = ratio_tab[limit];

        elm_mix.parent = elm_c->parent;
        elm_mix.css.left = elm_c->css.left;
        elm_mix.css.top = elm_c->css.top;
        elm_mix.css.width = elm_c->css.width;
        elm_mix.css.height = elm_c->css.height;
        ui_core_get_element_abs_rect(&elm_mix, &rect);

        x0 = rect.left + rect.width / 2;
        y0 = rect.top + rect.height / 2;
        icon_core_ori_cx = x0;
        icon_core_ori_cy = y0;
        x0 = x0 - radius;//转换为以屏幕中心为原点的坐标系
        y0 = radius - y0;//转换为以屏幕中心为原点的坐标系

    } else {
        x0 = layout_rect.left + layout_rect.width / 2;
        y0 = layout_rect.top + layout_rect.height / 2;
        icon_core_ori_cx = x0;
        icon_core_ori_cy = y0;
        x0 = x0 - radius;//转换为以屏幕中心为原点的坐标系
        y0 = radius - y0;//转换为以屏幕中心为原点的坐标系
    }
    /* printf("ori %d, %d, %d, %d\n", icon_core_ori_cx, icon_core_ori_cy, x0, y0); */
#endif


    list_for_each_entry(icon_p, root, entry) {

        if (icon_step != 0) {
            goto __icon_step_ctl;
        }

        int distance = abs(icon_p->cx - center_x) * abs(icon_p->cx - center_x) + abs(icon_p->cy - center_y) * abs(icon_p->cy - center_y);

        /* printf("dis %d\n", distance); */

        if (icon_p->size == -1) {
            if (distance < svi.ref_distance) {
                icon_p->size = 1;
            } else {
                icon_p->size = 2;
            }

            struct element elm;
            elm.parent = icon_p->elm->parent;
            elm.css.left = icon_p->css_left;
            elm.css.top = icon_p->css_top;
            elm.css.width = icon_p->css_width;
            elm.css.height = icon_p->css_height;
            ui_core_get_element_abs_rect(&elm, &rect);

#if IS_CIRCLE_SCREEN //圆屏

            r0 = rect.width / 2;
            cx = rect.left + r0;
            cy = rect.top + r0;
            disx = abs(cx - icon_core->cx);
            disy = abs(cy - icon_core->cy);
            d0 = complex_abs_float((float)disx, (float)disy) + r0;

            if (d0 > radius) {

                if ((icon_p->index <= 6) && (overflow == 0)) {
                    overflow = 1;
                    icon_p->size = -1;
                    goto __center_overflow;
                }

                xoffset = 0;
                yoffset = 0;
                icon_p->size = 3;

                r1 = r0 - (d0 - radius) / 2.0 - 8 / 2;
                if (icon_step == 0) {
                    if (2 * r1 > svi.ics[2].icon_w) {
                        r1 = svi.ics[2].icon_w / 2.0;
                    }
                }
                if ((r1 <= 0) || (r1 > r0)) {
                    cx = 0;
                    cy = 0;
                    r1 = 0;
                    goto __end_caculate;
                }
                r2 = radius - r1;
                r2 = r2 * r2;//r^2

                angle = get_angle(cx - icon_core_ori_cx, cy - icon_core_ori_cy);
                /* printf("index %d, angle: %d\n", icon_p->index, angle); */

                /* printf("r1\n"); */
                /* put_float(r1); */
                /* printf("r2\n"); */
                /* put_float(radius - r1); */

                if ((angle == 90) || (angle == 270)) {
                    cx = x0 + radius;//恢复为以左上角为原点的坐标系
                    y1 = root_float(r2 - x0 * x0);
                    y2 = -root_float(r2 - x0 * x0);
                    /* printf("cacu %d, %d, %d\n", cx, y1, y2); */

                    y1 = radius - y1;//恢复为以左上角为原点的坐标系
                    y2 = radius - y2;//恢复为以左上角为原点的坐标系
                    if (cy <= icon_core_ori_cy) {//在参考点上边
                        cy = (y1 <= icon_core_ori_cy) ? y1 : y2;
                    } else {
                        cy = (y1 > icon_core_ori_cy) ? y1 : y2;
                    }

                    /* printf("really %d, %d, %d, %d\n", icon_core_ori_cy, cy, y1, y2); */
                } else {

                    k = tan_float(angle / 180.f);//k
                    /* printf("k\n"); */
                    /* put_float(k); */

                    x1 = cx - radius;//转换为以屏幕中心为原点的坐标系
                    y1 = radius - cy;//转换为以屏幕中心为原点的坐标系
                    if (((x1 - x0 > 0) && (y1 - y0 > 0)) || ((x1 - x0 < 0) && (y1 - y0 < 0))) {//斜率为正数
                        k = abs(k);
                    } else {
                        k = -abs(k);
                    }
                    /* put_float(k); */
                    /* printf("\n"); */

                    a = (1 + k * k);//a
                    b = (2 * k * y0 - 2 * k * k * x0);//b
                    c = (y0 - k * x0) * (y0 - k * x0) - r2; //c

                    x1 = (-b + root_float(b * b - 4 * a * c)) / (2 * a);
                    x2 = (-b - root_float(b * b - 4 * a * c)) / (2 * a);
                    y1 = k * (x1 - x0) + y0;
                    y2 = k * (x2 - x0) + y0;

                    /* printf("cacu %d, %d, %d, %d\n", x1, y1, x2, y2); */

                    x1 = x1 + radius;//恢复为以左上角为原点的坐标系
                    x2 = x2 + radius;//恢复为以左上角为原点的坐标系
                    y1 = radius - y1;//恢复为以左上角为原点的坐标系
                    y2 = radius - y2;//恢复为以左上角为原点的坐标系

                    /* printf("tx %d, %d, %d\n", abs(cx - icon_core_ori_cx), abs(x1 - icon_core_ori_cx), abs(x2 - icon_core_ori_cx)); */
                    /* printf("ty %d, %d, %d\n", abs(cy - icon_core_ori_cy), abs(y1 - icon_core_ori_cy), abs(y2 - icon_core_ori_cy)); */

                    /* printf("really %d, %d, %d, %d, %d, %d\n", icon_core_ori_cx, icon_core_ori_cy, x1, y1, x2, y2); */

                    if (((x1 <= icon_core_ori_cx) && (x2 <= icon_core_ori_cx)) ||
                        ((x1 > icon_core_ori_cx) && (x2 > icon_core_ori_cx))) {//算出来的值都在参考点的同一边
                        comp0 = abs(cx - icon_core_ori_cx);
                        comp1 = abs(abs(x1 - icon_core_ori_cx) - comp0);
                        comp2 = abs(abs(x2 - icon_core_ori_cx) - comp0);
                        if (comp1 <= comp2) {
                            cx = x1;
                        } else {
                            cx = x2;
                        }
                    } else {
                        if (cx <= icon_core_ori_cx) {//在参考点左边
                            cx = (x1 <= icon_core_ori_cx) ? x1 : x2;
                        } else {
                            cx = (x1 > icon_core_ori_cx) ? x1 : x2;
                        }
                    }
                    if (((y1 <= icon_core_ori_cy) && (y2 <= icon_core_ori_cy)) ||
                        ((y1 > icon_core_ori_cy) && (y2 > icon_core_ori_cy))) {//算出来的值都在参考点的同一边
                        comp0 = abs(cy - icon_core_ori_cy);
                        comp1 = abs(abs(y1 - icon_core_ori_cy) - comp0);
                        comp2 = abs(abs(y2 - icon_core_ori_cy) - comp0);
                        if (comp1 <= comp2) {
                            cy = y1;
                        } else {
                            cy = y2;
                        }
                    } else {
                        if (cy <= icon_core_ori_cy) {//在参考点上边
                            cy = (y1 <= icon_core_ori_cy) ? y1 : y2;
                        } else {
                            cy = (y1 > icon_core_ori_cy) ? y1 : y2;
                        }
                    }
                }
                cx -= r1;
                cy -= r1;

                /* printf("cx %d, cy %d\n", cx, cy); */

                /* printf("info: %d, %d\n", cx, cy); */
                /* put_float(tx); */
                /* put_float(ty); */
                /* put_float(r1); */
                /* printf("\n"); */

__end_caculate:
                if (icon_step != 0) {
                    s_icon = limit;
                    if (icon_step < 0) {
                        s_icon = s_icon - icon_step;
                        s_icon = (s_icon > limit) ? limit : s_icon;
                    } else {
                        s_icon = s_icon - icon_step;
                        s_icon = (s_icon < 0) ? 0 : s_icon;
                    }
                    cx = svi.ics[s_icon].icon_w;
                    cy = svi.ics[s_icon].icon_h;
                    xoffset = 0;
                    yoffset = 0;
                    r0 = 0;
                }

            }

#else

            if ((rect.left < 0) || (rect.top < 0) || ((rect.left + rect.width) > svi.lcd_w) || ((rect.top + rect.height) > svi.lcd_h)) {

                xoffset = 0;
                yoffset = 0;
                icon_p->size = 3;

                cy = 10000;
                cx = 10000;
                if (rect.left < 0) {
                    cx = rect.left + rect.width;
                    xoffset = (abs(rect.left) / 2) * 10000 / layout_rect.width;
                    if (icon_step == 0) {
                        if (cx > svi.ics[2].icon_w) {
                            cx = svi.ics[2].icon_w;
                        }
                    }
                }
                if (rect.top < 0) {
                    cy = rect.top + rect.height;
                    yoffset = (abs(rect.top) / 2) * 10000 / layout_rect.height;
                    if (icon_step == 0) {
                        if (cy > svi.ics[2].icon_h) {
                            cy = svi.ics[2].icon_h;
                        }
                    }
                }
                if ((rect.left + rect.width) > svi.lcd_w) {
                    cx = svi.lcd_w - rect.left;
                    xoffset = -(abs(rect.width - cx) / 2) * 10000 / layout_rect.width;
                    if (icon_step == 0) {
                        if (cx > svi.ics[2].icon_w) {
                            cx = svi.ics[2].icon_w;
                        }
                    }
                }
                if ((rect.top + rect.height) > svi.lcd_h) {
                    cy = svi.lcd_h - rect.top;
                    yoffset = -(abs(rect.height - cy) / 2) * 10000 / layout_rect.height;
                    if (icon_step == 0) {
                        if (cy > svi.ics[2].icon_h) {
                            cy = svi.ics[2].icon_h;
                        }
                    }
                }

                if ((cx != 10000) && (cy != 10000)) {
                    cx = (cx > cy) ? cy : cx;
                } else {
                    if (cx == 10000) {
                        cx = cy;
                    } else {
                        cy = cx;
                    }
                }

                if (cx <= 0) {
                    xoffset = 0;
                    yoffset = 0;
                    cx = 0;
                    cy = 0;
                }
                if (icon_step != 0) {
                    s_icon = limit;
                    if (icon_step < 0) {
                        s_icon = s_icon - icon_step;
                        s_icon = (s_icon > limit) ? limit : s_icon;
                    } else {
                        s_icon = s_icon - icon_step;
                        s_icon = (s_icon < 0) ? 0 : s_icon;
                    }
                    cx = svi.ics[s_icon].icon_w;
                    cy = svi.ics[s_icon].icon_h;
                    xoffset = 0;
                    yoffset = 0;
                }

            } //end style_rc
#endif

        }

__icon_step_ctl:
        if (icon_step != 0) {
            if (icon_step < 0) {
                s_icon = abs(icon_step);
            } else {
                s_icon = 0;
            }
            s_icon = (s_icon > limit) ? limit : s_icon;
            s_icon = (s_icon < 0) ? 0 : s_icon;
            cx = svi.ics[s_icon].icon_w;
            cy = svi.ics[s_icon].icon_h;
            xoffset = 0;
            yoffset = 0;
            r0 = 0;
            icon_p->size = 3;
        }
        /* printf("%d, %d, %d, %d, %d, %d\n", icon_p->size, size0, size1, size2, size3, distance); */

        if (icon_p->size == 0) {
            struct element *elm = icon_p->elm;
            elm->css.left = icon_p->css_left;
            elm->css.top = icon_p->css_top;
            elm->css.width = icon_p->css_width;
            elm->css.height = icon_p->css_height;

            s_icon = 0;
            p_icon = limit;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

                elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
                elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            } else if (icon_step > 0) {
            } else {
            }

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size == 1) {
            struct element *elm = icon_p->elm;

            s_icon = 1;
            p_icon = 3;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

            } else if (icon_step > 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon < 0) ? 0 : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon > limit) ? limit : p_icon;
            } else {
            }

            elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
            elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size == 2) {
            struct element *elm = icon_p->elm;

            s_icon = 2;
            p_icon = 2;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

            } else if (icon_step > 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon < 0) ? 0 : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon > limit) ? limit : p_icon;
            } else {
            }
            elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
            elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size >= 3) {
            struct element *elm = icon_p->elm;

            /* if ((svi.lcd_w == 454) && (r0 > 0)) { */
            if (r0 > 0) {
                elm->css.width = 2 * r1 * 10000 / layout_rect.width;
                elm->css.height = 2 * r1 * 10000 / layout_rect.height;
                elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
                elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;

                /* printf("%d, %d, %d, %d, %d, %d\n", elm->css.left, elm->css.top, rect.left, rect.top, layout_elm->css.left, layout_elm->css.top); */
                /* struct rect test_rect; */
                /* struct element test_elm; */
                /* test_elm.parent = icon_p->elm->parent; */

                /* test_elm.css.left = elm->css.left; */
                /* test_elm.css.top = elm->css.top; */
                /* test_elm.css.width = elm->css.width; */
                /* test_elm.css.height = elm->css.height; */
                /* ui_core_get_element_abs_rect(&test_elm, &test_rect); */
                /* printf("\n\ntest %d, %d, %d, %d\n\n", test_rect.left, test_rect.top, test_rect.width, test_rect.height); */

                ratio = (float)r1 / r0;
                elm->css.ratio.en = 1;
                elm->css.ratio.ratio_w = ratio;
                elm->css.ratio.ratio_h = ratio;

                if (icon_step == 0) {
                    if (elm->css.ratio.ratio_w > 0.1) {
                        elm->css.ratio.ratio_w -= 0.05;
                        elm->css.ratio.ratio_h -= 0.05;
                    }
                }

            } else {
                elm->css.width = cx * 10000 / layout_rect.width;
                elm->css.height = cy * 10000 / layout_rect.height;

                elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2 + xoffset;
                elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2 + yoffset;

                ratio = (float)cx / rect.width;
                elm->css.ratio.en = 1;
                elm->css.ratio.ratio_w = ratio;
                elm->css.ratio.ratio_h = ratio;

                if (icon_step != 0) {
                    elm->css.ratio.ratio_w -= 0.03;
                    elm->css.ratio.ratio_h -= 0.03;
                }

                /* printf("\nratio"); */
                /* put_float(ratio); */
                /* printf("\n"); */

                /* struct rect test_rect; */
                /* struct element test_elm; */

                /* test_elm.parent = icon_p->elm->parent; */
                /* test_elm.css.left = elm->css.left; */
                /* test_elm.css.top = elm->css.top; */
                /* test_elm.css.width = elm->css.width; */
                /* test_elm.css.height = elm->css.height; */
                /* ui_core_get_element_abs_rect(&test_elm, &test_rect); */
                /* printf("\n\ntest %d, %d, %d, %d\n\n", test_rect.left, test_rect.top, test_rect.width, test_rect.height); */
            }
        }

    }

    if (icon_step != 0) {
        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->css_left;
        elm_mix.css.top = icon_core->css_top;
        elm_mix.css.width = icon_core->css_width;
        elm_mix.css.height = icon_core->css_height;
        ui_core_get_element_abs_rect(&elm_mix, &rect);

        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->elm->css.left;
        elm_mix.css.top = icon_core->elm->css.top;
        elm_mix.css.width = icon_core->elm->css.width;
        elm_mix.css.height = icon_core->elm->css.height;
        ui_core_get_element_abs_rect(&elm_mix, &icon_core_rect);

        icon_core_ori_cx = icon_core->left + icon_core->width / 2;
        icon_core_ori_cy = icon_core->top + icon_core->height / 2;
        icon_core_cx = icon_core_rect.left + icon_core_rect.width / 2;
        icon_core_cy = icon_core_rect.top + icon_core_rect.height / 2;

        list_for_each_entry(icon_p, root, entry) {

            if (icon_p == icon_core) {
                continue;
            }

            elm_mix.parent = icon_p->elm->parent;
            elm_mix.css.left = icon_p->elm->css.left;
            elm_mix.css.top = icon_p->elm->css.top;
            elm_mix.css.width = icon_p->elm->css.width;
            elm_mix.css.height = icon_p->elm->css.height;
            ui_core_get_element_abs_rect(&elm_mix, &cur_rect);

            r1 = cur_rect.width / 2;
            r0 = icon_p->width / 2;
            cx = icon_p->left + r0;
            cy = icon_p->top + r0;
            disx = abs(cx - icon_core_ori_cx);
            disy = abs(cy - icon_core_ori_cy);
            d0 = complex_abs_float((float)disx, (float)disy);

            /* printf("info: %d, %d, %d, %d, %d", r0, cx, cy, disx, disy); */
            /* put_float(r1); */
            /* put_float(d0); */

            d0 = d0 * (r1 / r0) + 0.5;
            angle = get_angle(cx - icon_core_ori_cx, cy - icon_core_ori_cy);

            tx = cos_float(angle / 180.f) * d0;
            ty = sin_float(angle / 180.f) * d0;

            /* put_float(tx); */
            /* put_float(ty); */

            if ((angle >= 270) || (angle <= 90)) {
                cx = icon_core_cx + abs(tx) - r1 - 1;
            } else {
                cx = icon_core_cx - abs(tx) - r1 + 1;
            }
            if ((angle >= 0) && (angle <= 180)) {
                cy = icon_core_cy + abs(ty) - r1 - 1;
            } else {
                cy = icon_core_cy - abs(ty) - r1 + 1;
            }

            //testcccc
            /* disx = abs(cx + r1 - icon_core_cx); */
            /* disy = abs(cy + r1 - icon_core_cy); */
            /* d0 = complex_abs_float((float)disx, (float)disy); */
            /* printf("\nccc:%d, %d, %d, %d\n", icon_dsize, icon_core_dsize, disx, disy); */
            /* put_float(d0); */
            /* printf("\n"); */
            icon_p->elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
            icon_p->elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;
        }
    }

    if (icon_step != 0) {
        list_for_each_entry(icon_p, root, entry) {
            if (icon_p->index == center_index) {
                icon_p->size = 0;//记录中心图标的圆心位置 */
                break;
            }
        }
    }

    if (draw) {
        ui_core_redraw(elm);
    }

    return 0;
}


#elif (SVI_USE_SPHERE)//for #if (SVI_USE_NORMAL)


#define USE_WEIGHT		1
#define PI 3.14159

#define SCREEN_W 454//屏幕宽度,根据需要调整
#define SCREEN_H 454//屏幕高度,根据需要调整
/* #define SCREEN_W 240//屏幕宽度,根据需要调整 */
/* #define SCREEN_H 240//屏幕高度,根据需要调整 */
#define SCREEN_R_W  (int)(SCREEN_W / 2)
#define SCREEN_R_H  (int)(SCREEN_H / 2)

#define MAX_SIDE  MAX(SCREEN_W, SCREEN_H)
#define MIN_SIDE  MIN(SCREEN_W, SCREEN_H)

#define CX_OFFSET		(int)(-40)//根据需要调整
#define CY_OFFSET		(int)(-40)//根据需要调整
/* #define CX_OFFSET		(int)(50)//根据需要调整 */
/* #define CY_OFFSET		(int)(50)//根据需要调整 */

#define w_scale		(float)(SCREEN_W / 454.0)//这里分母的454，不是屏幕的尺寸概念，一般不需要改
#define h_scale     (float)(SCREEN_H / 454.0)//这里分母的454，不是屏幕的尺寸概念，一般不需要改
#define init_scale  (float)(MAX_SIDE / 454.0)//这里分母的454，不是屏幕的尺寸概念，一般不需要改

#define FLAT_R   (int)(20)
#define TAIL_R  (int)(8)

#define THETA  (float)(PI*80/180)
#define THETA_NO_PI  (float)80/180

#if USE_WEIGHT
#define SPHERE_R_W  (float)((SCREEN_R_W - FLAT_R - TAIL_R) / sin_float(THETA_NO_PI))
#define SPHERE_R_H  (float)((SCREEN_R_H - FLAT_R - TAIL_R) / sin_float(THETA_NO_PI))
#else
#define SPHERE_R_W  (float)((MIN_SIDE/2 - FLAT_R - TAIL_R) / sin_float(THETA_NO_PI))
#define SPHERE_R_H  (float)((MIN_SIDE/2 - FLAT_R - TAIL_R) / sin_float(THETA_NO_PI))
#endif

#define VISIBLE_R_W  (float)(SPHERE_R_W*THETA + FLAT_R)
#define VISIBLE_R_H  (float)(SPHERE_R_H*THETA + FLAT_R)

//图标参数,这里填图标的实际半径, 根据需要调整!!!
//一般屏幕缩小和图标缩小的比例相同，所以才直接乘以init_scale
/* #define icon_r  (int)(45*init_scale) */
/* #define grid_r  (int)(48*init_scale) */
/* #define icon_r  (int)(35) */
/* #define grid_r  (int)(38) */

#define icon_r  (int)(45)


#define USE_DIFF_ICON			0


#if USE_DIFF_ICON

#define STEP_SCALE_MIN 		(float)(0.30)//拨码器缩放的最小值，不能改
#define STEP_SCALE_MAX 		(float)(2.00)//拨码器缩放的最大值，不能改

#define ICON_STEP_LIMIT		5//限制拨码器缩小或者放大的级别数，如果修改该值，相应的表也要修改
#define STEP_TAB_NUM		(ICON_STEP_LIMIT * 2)

static float step_scale = 1.00;
//拨码器缩放系数，可根据不同屏幕大小修改
static float step_scale_tab[STEP_TAB_NUM] = {0.95, 0.80, 0.60, 0.40, STEP_SCALE_MIN, 1.25, 1.40, 1.60, 1.80, STEP_SCALE_MAX};

#endif

//不同屏幕的初始化参数，根据需要调整！！！
static int startlight_svi_init()
{
    if (svi.init) {
        return 0;
    }

    /* svi.lcd_w = 454;//这里写屏幕的实际大小 */
    /* svi.lcd_h = 454; */
    svi.lcd_w = SCREEN_W;//这里写屏幕的实际大小
    svi.lcd_h = SCREEN_H;

    /*** 对于使用SVI_USE_SPHERE方式的满天星，svi.ics这部分只用于拨码器缩放 ***/
    svi.icon_level = 5;
    svi.ics = malloc(svi.icon_level * sizeof(struct icon_size_info));
    if (svi.ics == NULL) {
        printf("err malloc ics \n");
        return -1;
    }

    svi.ics[0].icon_w = 45 * 2;
    svi.ics[0].icon_h = 45 * 2;

    svi.ics[1].icon_w = 41 * 2;
    svi.ics[1].icon_h = 41 * 2;

    svi.ics[2].icon_w = 39 * 2;
    svi.ics[2].icon_h = 39 * 2;

    svi.ics[3].icon_w = 22 * 2;
    svi.ics[3].icon_h = 22 * 2;

    svi.ics[4].icon_w = 16 * 2;
    svi.ics[4].icon_h = 16 * 2;

    /******************************************************/

    svi.init = 1;

    return 0;
}




//距离映射
//w1:高的权重
//w2:宽的权重
#if USE_WEIGHT
static float map_dist(float d, float w1, float w2)
#else
static float map_dist(float d, float flag)
#endif
{
    float VISIBLE_R = VISIBLE_R_H;
    float SPHERE_R = SPHERE_R_H;
    int SCREEN_R = SCREEN_R_H;
    float newd, radio_d;

#if USE_WEIGHT
    VISIBLE_R = w1 * VISIBLE_R_H + w2 * VISIBLE_R_W;
    SPHERE_R = w1 * SPHERE_R_H + w2 * SPHERE_R_W;
    SCREEN_R = w1 * SCREEN_R_H + w2 * SCREEN_R_W;
#else
    if (flag) {
        VISIBLE_R = VISIBLE_R_W;
        SPHERE_R = SPHERE_R_W;
        SCREEN_R = SCREEN_R_W;
    }
#endif
    if (d < FLAT_R) {
        newd = d;
        radio_d = 1.0;
    } else if (d >= VISIBLE_R) {
        newd = SCREEN_R - TAIL_R;
        radio_d = newd / d;
    } else {
        newd = FLAT_R + SPHERE_R * sin_float(((d - FLAT_R) / SPHERE_R) / PI);

        radio_d = newd / d;
    }

    return radio_d;
}

//尺度映射
//w1:高的权重
//w2:宽的权重
static float map_scale_constrain(float d, float flag, float radio_d)
{
    float newd = radio_d * d;
    float new_icon_r = SCREEN_R_H  - newd;

    if (flag) {
        new_icon_r = SCREEN_R_W  - newd;
    }
    return new_icon_r / icon_r;
}
//尺度映射
//w1:高的权重
//w2:宽的权重
#if USE_WEIGHT
void map_scale(float d, float w1, float w2, float *scale, float *radio_d)
#else
void map_scale(float d, float flag, float *scale, float *radio_d)
#endif
{
#if USE_WEIGHT
    float radio_d_ = map_dist(d, w1, w2);
#else
    float radio_d_ = map_dist(d, flag);
    float scale_constrain = map_scale_constrain(d, flag, radio_d_);
    float th;
#endif
    float scale_;

#if USE_WEIGHT
    if (d > 1) {
        scale_ = map_dist(d, w1, w2) * d - map_dist(d - 1, w1, w2) * (d - 1);
    } else {
        scale_ = 1;
    }
#else
    th = 300 * h_scale;
    if (flag) {
        th = 300 * w_scale;
    }
    if (d > 1) {
        scale_ = map_dist(d, flag) * d - map_dist(d - 1, flag) * (d - 1);
    } else {
        scale_ = 1;
    }
    scale_ = (d < th) ? scale_ : scale_constrain;
#endif

    *scale = scale_;
    *radio_d = radio_d_;
    return;
}

/*
screen:屏幕buf
cx，cy，滑动的中心点坐标
*/
void show_icon(struct list_head *root, struct element *layout_elm, int cx, int cy)
{
    float d, sx, sy, VISIBLE_R;
    int flag;
    int x, y;
    /* int newx, newy; */
    float newx, newy;
    float icon_w, icon_h;
    float ratio;
    struct rect layout_rect;
    struct icon_list *icon_p;
    float new_scale, radio_d;
    struct element *elm;
#if USE_WEIGHT
    float w1, w2;
    float cur_sx, cur_sy;

#if USE_DIFF_ICON
    float icon_r_tmp = icon_r * step_scale;
#else
    float icon_r_tmp = icon_r;
#endif

#endif

    /* printf("cx %d, cy %d\n", cx, cy); */

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);

    list_for_each_entry(icon_p, root, entry) {

        //原始坐标和宽高
#if USE_DIFF_ICON
        x = icon_p->left * step_scale;
        y = icon_p->top * step_scale;
#else
        x = icon_p->left;
        y = icon_p->top;
#endif

        icon_w = (float)icon_p->width;
        icon_h = (float)icon_p->height;
        elm = icon_p->elm;

        /* d = distance(icon_grids[j][i].x, icon_grids[j][i].y, cx, cy); */
        /* sx = icon_grids[j][i].x - cx;//相对偏移 */
        /* sy = icon_grids[j][i].y - cy; */
        sx = x - cx;
        sy = y - cy;

        /* d = (abs(sx) > abs(sy)) ? abs(sx) : abs(sy); */
        d = complex_abs_float(sx, sy);

#if USE_WEIGHT
        if (abs(sx) == abs(sy)) {
            w1 = 0.5;
            w2 = 0.5;
        } else {
            w1 = abs(sy) / (abs(sx) + abs(sy));
            w2 = 1 - w1;
        }
        VISIBLE_R = w1 * VISIBLE_R_H + w2 * VISIBLE_R_W;
#else
        flag = 0;
        VISIBLE_R = VISIBLE_R_H;
        if (abs(sx) > abs(sy)) {
            flag = 1;
            VISIBLE_R = VISIBLE_R_W;
        }
#endif
        if ((d < VISIBLE_R) && (d >= 0)) {
#if USE_WEIGHT
            map_scale(d, w1, w2, &new_scale, &radio_d);
#else
            map_scale(d, flag, &new_scale, &radio_d);
#endif


#if USE_DIFF_ICON
            new_scale = new_scale * step_scale;
#endif
            sx = sx * radio_d;
            sy = sy * radio_d;

#if USE_WEIGHT
            cur_sx = sx + SCREEN_R_W;
            cur_sy = sy + SCREEN_R_H;
            if (SCREEN_W <= SCREEN_H) {
                if ((cur_sx < SCREEN_R_W) && (cur_sx < new_scale * icon_r_tmp)) {
                    new_scale = cur_sx / icon_r_tmp;
                } else if ((cur_sx > SCREEN_R_W) && (SCREEN_R_W * 2 - cur_sx < new_scale * icon_r_tmp)) {
                    new_scale = (SCREEN_R_W * 2 - cur_sx) / icon_r_tmp;
                }
            } else {
                if ((cur_sy < SCREEN_R_H) && (cur_sy < new_scale * icon_r_tmp)) {
                    new_scale = cur_sy / icon_r_tmp;
                } else if ((cur_sy > SCREEN_R_H) && (SCREEN_R_H * 2 - cur_sy < new_scale * icon_r_tmp)) {
                    new_scale = (SCREEN_R_H * 2 - cur_sy) / icon_r_tmp;
                }
            }
#endif

            //新的缩放比例
            /* ratio = new_scale*init_scale; */
            ratio = new_scale;

            //新的左上角坐标
            newx = (sx + SCREEN_R_W) - (icon_w * ratio) / 2;
            newy = (sy + SCREEN_R_H) - (icon_h * ratio) / 2;

            /* newx += 100; */
            /* newy += 100;	 */
            /* printf("index %d, newx %d, newy %d, new_size %d\n", icon_p->index, (int)newx, (int)newy, (int)(icon_w * ratio) / 2); */
            /* put_float(new_scale); */
            /* put_float(ratio); */
            /* put_float((icon_w * ratio) / 2); */
            /* put_float(d); */
            /* printf("\n"); */

            if (new_scale <= 0) {
                printf("new_scale err\n");
                put_float(new_scale);
                while (1);
            }


            //转换成SDK的参数
            elm->css.width = (icon_w * ratio) * 10000 / layout_rect.width;
            elm->css.height = (icon_h * ratio) * 10000 / layout_rect.height;
            elm->css.left = (newx - layout_rect.left) * 10000 / layout_rect.width;
            elm->css.top = (newy - layout_rect.top) * 10000 / layout_rect.height;
            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio;
            elm->css.ratio.ratio_h = ratio;

            /* int tmp; */
            /* if (ratio < 0.5) { */
            /* tmp = (int)(icon_w * ratio); */
            /* elm->css.ratio.ratio_w = (float)tmp / icon_w; */
            /* tmp = (int)(icon_h * ratio); */
            /* elm->css.ratio.ratio_h = (float)tmp / icon_h; */
            /* } */

            /* printf("%d, %d, %d, %d\n", elm->css.width, elm->css.height, elm->css.left, elm->css.top); */

            /* img = icon_grids[j][i].img;//图像buf */
            /* drawImage(screen, img,  sx + SCREEN_R_W, sy + SCREEN_R_H, new_scale*init_scale，icon_r*2，icon_r*2)//将坐标转换为以cx,cy为中心的坐标空间 */
            //sx + SCREEN_R_W,sy + SCREEN_R_H需要显示在屏幕上的坐标
            //new_scale*init_scale图像的缩放比例
        } else {
            //转换成SDK的参数
            elm->css.width = 0;
            elm->css.height = 0;
            elm->css.left = 0;
            elm->css.top = 0;
            elm->css.ratio.en = 0;
            elm->css.ratio.ratio_w = 0;
            elm->css.ratio.ratio_h = 0;
        }
    }
}



int icon_change(struct list_head *root, struct element *layout_elm, int draw)
{
    struct rect layout_rect;
    int cx, cy;
    int s_icon;
    struct element *elm;
    struct element elm_mix;
    int limit = svi.icon_level - 1;
    struct icon_list *icon_core = svi.icon_core;
    struct rect icon_core_rect;
    struct icon_list *icon_p;
    float r0, r1, d0, tx, ty, ratio;
    int icon_core_ori_cx, icon_core_ori_cy;
    int icon_core_cx, icon_core_cy;
    int disx, disy;
    int angle;
    struct rect cur_rect;

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);

    /* printf("layout %d, %d, %d, %d\n", layout_rect.left, layout_rect.top, layout_rect.width, layout_rect.height); */

    if (icon_step == 0) {
        cx = layout_rect.left + layout_rect.width / 2;
        cy = layout_rect.top + layout_rect.height / 2;
        cx = SCREEN_W - cx + CX_OFFSET;
        cy = SCREEN_H - cy + CY_OFFSET;

#if USE_DIFF_ICON
        step_scale = 1;
#endif
        show_icon(root, layout_elm, cx, cy);
    } else {

#if USE_DIFF_ICON
        int step;
        int step_limit;

        step = icon_step;
        if (step < 0) {
            step = abs(step) - 1;
        } else {
            step = ICON_STEP_LIMIT + (step - 1);
        }
        step_limit = STEP_TAB_NUM - 1;
        step = (step > step_limit) ? step_limit : step;
        step_scale = step_scale_tab[step];

        cx = layout_rect.left + layout_rect.width / 2;
        cy = layout_rect.top + layout_rect.height / 2;
        cx = SCREEN_W - cx + CX_OFFSET;
        cy = SCREEN_H - cy + CY_OFFSET;

        show_icon(root, layout_elm, cx, cy);
#else

        if (icon_step < 0) {
            s_icon = abs(icon_step);
        } else {
            s_icon = 0;
        }
        s_icon = (s_icon > limit) ? limit : s_icon;
        s_icon = (s_icon < 0) ? 0 : s_icon;
        cx = svi.ics[s_icon].icon_w;
        cy = svi.ics[s_icon].icon_h;

        list_for_each_entry(icon_p, root, entry) {
            elm = icon_p->elm;
            elm->css.width = cx * 10000 / layout_rect.width;
            elm->css.height = cy * 10000 / layout_rect.height;
            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            ratio = (float)cx / icon_p->width;
            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio;
            elm->css.ratio.ratio_h = ratio;
        }
        /* ratio = ratio * 0.92; */

        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->elm->css.left;
        elm_mix.css.top = icon_core->elm->css.top;
        elm_mix.css.width = icon_core->elm->css.width;
        elm_mix.css.height = icon_core->elm->css.height;
        ui_core_get_element_abs_rect(&elm_mix, &icon_core_rect);

        icon_core_ori_cx = icon_core->left + icon_core->width / 2;
        icon_core_ori_cy = icon_core->top + icon_core->height / 2;
        icon_core_cx = icon_core_rect.left + icon_core_rect.width / 2;
        icon_core_cy = icon_core_rect.top + icon_core_rect.height / 2;

        list_for_each_entry(icon_p, root, entry) {

            if (icon_p == icon_core) {
                continue;
            }

            elm_mix.parent = icon_p->elm->parent;
            elm_mix.css.left = icon_p->elm->css.left;
            elm_mix.css.top = icon_p->elm->css.top;
            elm_mix.css.width = icon_p->elm->css.width;
            elm_mix.css.height = icon_p->elm->css.height;
            ui_core_get_element_abs_rect(&elm_mix, &cur_rect);

            r1 = cur_rect.width / 2;
            r0 = icon_p->width / 2;
            cx = icon_p->left + r0;
            cy = icon_p->top + r0;
            disx = abs(cx - icon_core_ori_cx);
            disy = abs(cy - icon_core_ori_cy);
            d0 = complex_abs_float((float)disx, (float)disy);

            d0 = d0 * (r1 / r0) + 0.5;
            angle = get_angle(cx - icon_core_ori_cx, cy - icon_core_ori_cy);

            tx = cos_float(angle / 180.f) * d0;
            ty = sin_float(angle / 180.f) * d0;

            if ((angle >= 270) || (angle <= 90)) {
                cx = icon_core_cx + abs(tx) - r1 - 1;
            } else {
                cx = icon_core_cx - abs(tx) - r1 + 1;
            }
            if ((angle >= 0) && (angle <= 180)) {
                cy = icon_core_cy + abs(ty) - r1 - 1;
            } else {
                cy = icon_core_cy - abs(ty) - r1 + 1;
            }

            icon_p->elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
            icon_p->elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;

            /* icon_p->elm->css.ratio.ratio_w = ratio; */
            /* icon_p->elm->css.ratio.ratio_h = ratio; */
        }

#endif//#if USE_DIFF_ICON

    }

    if (draw) {
        ui_core_redraw(elm);
    }

    return 0;
}


#else   //SVI_USE_ARBIRECT

/*SVI_USE_ARBIRECT方式可调整in_H_inter(屏高), in_W_inter(屏宽),
 *circle_r(圆角矩形半径),in_W(外接矩形的宽，和circle_r有关系,max_w()),
 *in_H(外接矩形的高，和circle_r有关系,max_h()),CX_OFFSET/CY_OFFSET(模型移动中心点的偏移，
 *用于让整体显示居中,因为算法算出来的整体显示有偏差，具体确定方法：先将CX_OFFSET/CY_OFFSET设置为0,
 *然后初次显示,打印show_icon()函数传入的cx和cy,然后滑动界面让整体居中，看这时候的cx和cy，两次打印出来
 *差值就是需要偏移的值),icon_r(图标的实际半径)
 * */

#define PI 3.14159
#define TEST_DISTANCE	0

#if TEST_DISTANCE
#define DIS		(float)(0.5)
#endif

#define in_W_inter	454	//屏幕宽度,根据需要调整
#define in_H_inter 454//屏幕高度,根据需要调整
#define circle_r  200//圆角矩阵半径,必须小于in_W_inter/in_H_inter的一半，因为circle_w/circle_h的公式;根据需要调整
/* #define in_W_inter	300	//屏幕宽度,根据需要调整 */
/* #define in_H_inter 360//屏幕高度,根据需要调整 */
/* #define circle_r  70//圆角矩阵半径,必须小于in_W_inter/in_H_inter的一半，因为circle_w/circle_h的公式;根据需要调整 */
#define circle_w  (in_W_inter - 2*circle_r)//圆角矩阵内部矩形宽
#define circle_h  (in_H_inter - 2*circle_r)//圆角矩阵内部矩形高

static float max_w()//外接矩形的宽
{
    return complex_abs_float((circle_r + circle_w / 2), (circle_h / 2)) * 2;
}

static float max_h()//外接矩形的高
{
    return complex_abs_float((circle_r + circle_h / 2), (circle_w / 2)) * 2;
}

/*关于in_W/in_H的值的确定
 *1.根据具体方屏模具的形状，以及屏的尺寸,大概确定圆角矩形的半径circle_r
 *2.根据函数max_w()打印出来,根据函数max_h()打印出来,将打印出来的值赋
 给in_W和in_H两个宏（记住打印出来后，要重新将这两个值赋值成宏定义，不然
 还是原来的宏的值，没有效果！！！）
 *3.根据效果可反复调整圆角矩形半径circle_r,也就是重复第一步和第二步；也可以直接
 *微调in_H/in_W,例如in_W算出来是394，调整成400
*#define in_W		max_w()//必须比in_W_inter大
*#define in_H		max_h()//必须比in_H_inter大
 */
#define in_W  457	//根据需要调整
#define in_H  457	//根据需要调整
/* #define in_W  374		 */
/* #define in_H  400		 */
#define stand_l    MIN(in_W, in_H)
/* #define stand_l    MAX(in_W, in_H) */
#define correct_w_s ((float)in_W / (float)stand_l)
#define correct_h_s ((float)in_H / (float)stand_l)
#define space_x		((in_W - in_W_inter) / 2)
#define space_y		((in_H - in_H_inter) / 2)

#define stand_SCREEN_R		(stand_l / 2)
#define init_scale  (float)(stand_l / 454.0)

//#内部矩形区域
#define x_min  space_x
#define y_min  space_y
#define x_max  (x_min + in_W_inter)
#define y_max  (y_min + in_H_inter)

#define SCREEN_W in_W
#define SCREEN_H in_H
#define SCREEN_R_W  (int)(SCREEN_W / 2)
#define SCREEN_R_H  (int)(SCREEN_H / 2)
#define SPHERE_R_W  SCREEN_R_W
#define SPHERE_R_H  SCREEN_R_H

#define CX_OFFSET		(int)(-50 + 45)//根据需要调整
#define CY_OFFSET		(int)(-50 + 55)//根据需要调整
/* #define CX_OFFSET		(int)(-50 + 117)//根据需要调整 */
/* #define CY_OFFSET		(int)(-50 + 151)//根据需要调整 */

#define FLAT_R   (int)(20)
#define TAIL_R  (int)(8)

#define THETA  (float)(PI*80/180)
#define THETA_NO_PI  (float)80/180

#define stand_SPHERE_R  (float)((stand_SCREEN_R - FLAT_R - TAIL_R) / sin_float(THETA_NO_PI))
#define stand_VISIBLE_R  (float)(stand_SPHERE_R * THETA + FLAT_R)

//图标参数,这里填图标的实际半径, 根据需要调整!!!
#define icon_r  (int)(45)


#define USE_DIFF_ICON			0


#if USE_DIFF_ICON

#define STEP_SCALE_MIN 		(float)(0.30)//拨码器缩放的最小值，不能改
#define STEP_SCALE_MAX 		(float)(2.00)//拨码器缩放的最大值，不能改

#define ICON_STEP_LIMIT		5//限制拨码器缩小或者放大的级别数，如果修改该值，相应的表也要修改
#define STEP_TAB_NUM		(ICON_STEP_LIMIT * 2)

static float step_scale = 1.00;
//拨码器缩放系数，可根据不同屏幕大小修改
static float step_scale_tab[STEP_TAB_NUM] = {0.95, 0.80, 0.60, 0.40, STEP_SCALE_MIN, 1.25, 1.40, 1.60, 1.80, STEP_SCALE_MAX};

#endif

//不同屏幕的初始化参数，根据需要调整！！！
static int startlight_svi_init()
{
    if (svi.init) {
        return 0;
    }

    svi.lcd_w = in_W_inter;//这里写屏幕的实际大小
    svi.lcd_h = in_H_inter;

    /*** 对于使用SVI_USE_SPHERE方式的满天星，svi.ics这部分只用于拨码器缩放 ***/
    svi.icon_level = 5;
    svi.ics = malloc(svi.icon_level * sizeof(struct icon_size_info));
    if (svi.ics == NULL) {
        printf("err malloc ics \n");
        return -1;
    }

    svi.ics[0].icon_w = 45 * 2;
    svi.ics[0].icon_h = 45 * 2;

    svi.ics[1].icon_w = 41 * 2;
    svi.ics[1].icon_h = 41 * 2;

    svi.ics[2].icon_w = 39 * 2;
    svi.ics[2].icon_h = 39 * 2;

    svi.ics[3].icon_w = 22 * 2;
    svi.ics[3].icon_h = 22 * 2;

    svi.ics[4].icon_w = 16 * 2;
    svi.ics[4].icon_h = 16 * 2;

    /******************************************************/

    svi.init = 1;

    return 0;
}


//距离映射
static float map_dist(float d)
{
    float VISIBLE_R = stand_VISIBLE_R;
    float SPHERE_R = stand_SPHERE_R;
    int SCREEN_R = stand_SCREEN_R;
    float newd, radio_d;


    if (d < FLAT_R) {
        newd = d;
        radio_d = 1.0;
    } else if (d >= VISIBLE_R) {
        newd = SCREEN_R - TAIL_R;
        radio_d = newd / d;
    } else {
        newd = FLAT_R + SPHERE_R * sin_float(((d - FLAT_R) / SPHERE_R) / PI);

        radio_d = newd / d;
    }

    return radio_d;
}

//尺度映射
static float map_scale_constrain(float d, float radio_d)
{
    float newd = radio_d * d;
    float new_icon_r = stand_SCREEN_R  - newd;

    return new_icon_r / icon_r;
}
//尺度映射
void map_scale(float d, float *scale, float *radio_d)
{
    float radio_d_ = map_dist(d);
    float scale_constrain = map_scale_constrain(d, radio_d_);
    float th;
    float scale_;

    th = 300 * init_scale;
    if (d > 1) {
        scale_ = map_dist(d) * d - map_dist(d - 1) * (d - 1);
    } else {
        scale_ = 1;
    }
    scale_ = (d < th) ? scale_ : scale_constrain;

    *scale = scale_;
    *radio_d = radio_d_;
    return;
}

static float get_scale(float *disp_x, float *disp_y, float scale, float icon_w, float icon_h)
{
    int cx_int, cy_int;
    int dis_x_min, dis_y_min;
    int dis_x_max, dis_y_max;
    int new_icon_cx, new_icon_cy;
    int new_cols, new_rows;
    int beyond_dis;
    int icon_cx, icon_cy;

    cx_int = (int)(*disp_x);
    cy_int = (int)(*disp_y);

    icon_cx = icon_w / 2;
    icon_cy = icon_h / 2;
    new_cols = icon_cx * scale + 1;
    new_cols = new_cols * 2 + 1;
    new_rows = icon_cy * scale + 1;
    new_rows = new_rows * 2 + 1;
    new_icon_cy = new_rows / 2;
    new_icon_cx = new_cols / 2;

    dis_x_min = cx_int - new_icon_cx;
    dis_y_min = cy_int - new_icon_cy;
    dis_x_max = dis_x_min + new_cols;
    dis_y_max = dis_y_min + new_rows;

    if ((*disp_y < y_min) || (*disp_y > y_max) || (*disp_x < x_min) || (*disp_x > x_max)) { //#网格坐标再内部区域外
        /* printf("out_here\n"); */
        /* printf("%d, %d, %d, %d\n", y_min, y_max, x_min, x_max); */
        /* put_float(*disp_x); */
        /* put_float(*disp_y); */
        return 0;
    }
    beyond_dis = 0;
    if (dis_y_min < y_min) {
        beyond_dis = y_min - dis_y_min;
#if TEST_DISTANCE
        scale = scale * (new_rows - beyond_dis * 2 * (1 - DIS)) / new_rows;
        *disp_y = *disp_y + (float)beyond_dis * DIS;
#else
        scale = scale * (new_rows - beyond_dis * 2) / new_rows;
#endif
        /* printf("a1 %d\n", beyond_dis); */
        /* put_float(icon_w); */
        /* put_float(icon_h); */
        /* put_float(new_rows); */
        /* put_float(scale); */
        /* printf("\n"); */
        return scale;
    }
    if (dis_y_max > y_max) {
        beyond_dis = dis_y_max - y_max;
#if TEST_DISTANCE
        scale = scale * (new_rows - beyond_dis * 2 * (1 - DIS)) / new_rows;
        *disp_y = *disp_y - (float)beyond_dis * DIS;
#else
        scale = scale * (new_rows - beyond_dis * 2) / new_rows;
#endif
        /* printf("a2 %d\n", beyond_dis); */
        /* put_float(icon_w); */
        /* put_float(icon_h); */
        /* put_float(new_rows); */
        /* put_float(scale); */
        /* printf("\n"); */
        return scale;
    }
    if (dis_x_min < x_min) {
        beyond_dis = x_min - dis_x_min;
#if TEST_DISTANCE
        scale = scale * (new_rows - beyond_dis * 2 * (1 - DIS)) / new_rows;
        *disp_x = *disp_x + (float)beyond_dis * DIS;
#else
        scale = scale * (new_rows - beyond_dis * 2) / new_rows;
#endif
        /* printf("a3 %d\n", beyond_dis); */
        /* put_float(icon_w); */
        /* put_float(icon_h); */
        /* put_float(new_rows); */
        /* put_float(scale); */
        /* printf("\n"); */
        return scale;
    }
    if (dis_x_max > x_max) {
        beyond_dis = dis_x_max - x_max;
#if TEST_DISTANCE
        scale = scale * (new_rows - beyond_dis * 2 * (1 - DIS)) / new_rows;
        *disp_x = *disp_x - (float)beyond_dis * DIS;
#else
        scale = scale * (new_rows - beyond_dis * 2) / new_rows;
#endif
        /* printf("a4 %d\n", beyond_dis); */
        /* put_float(icon_w); */
        /* put_float(icon_h); */
        /* put_float(new_rows); */
        /* put_float(scale); */
        /* printf("\n"); */
        return scale;
    }

    return scale;
}



/*
screen:屏幕buf
cx，cy，滑动的中心点坐标
*/
void show_icon(struct list_head *root, struct element *layout_elm, int cx, int cy)
{
    float d, sx, sy, VISIBLE_R, d1, d2, ds;
    int x, y;
    float newx, newy;
    float icon_w, icon_h;
    float ratio;
    struct rect layout_rect;
    struct icon_list *icon_p;
    float new_scale, radio_d;
    struct element *elm;

    /* printf("cx %d, cy %d\n", cx, cy); */
    /* int max_wi = (int)max_w(); */
    /* int max_hi = (int)max_h(); */
    /* printf("max_w %d, max_h %d\n", max_wi, max_hi); */

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);

    list_for_each_entry(icon_p, root, entry) {

        //原始坐标和宽高
        x = icon_p->left + icon_p->width / 2;
        y = icon_p->top + icon_p->height / 2;
#if USE_DIFF_ICON
        x = x * step_scale;
        y = y * step_scale;
#endif

        icon_w = (float)icon_p->width;
        icon_h = (float)icon_p->height;
        elm = icon_p->elm;

        /* d = distance(icon_grids[j][i].x, icon_grids[j][i].y, cx, cy); */
        /* sx = icon_grids[j][i].x - cx;//相对偏移 */
        /* sy = icon_grids[j][i].y - cy; */
        sx = x - cx;
        sy = y - cy;

        d = complex_abs_float(sx, sy);
        VISIBLE_R = stand_VISIBLE_R;
        if ((d < VISIBLE_R) && (d >= 0)) {
            map_scale(d, &new_scale, &radio_d);

            sx = sx * radio_d;
            sy = sy * radio_d;

            /* d1 = complex_abs_float(sx, sy); */
            sx = sx * correct_w_s;
            sy = sy * correct_h_s;
            /* d2 = complex_abs_float(sx, sy); */
            /* if (d2 != 0) { */
            /* ds = d1 / d2; */
            /* new_scale = new_scale * ds; */
            /* } */


            /* if (icon_p->index == 0){ */
            /* printf("step1:\n"); */
            /* put_float(sx); */
            /* put_float(sy); */
            /* put_float(correct_w_s); */
            /* put_float(correct_h_s); */
            /* g_flag = 1; */
            /* } */

            float disp_x = sx + SCREEN_R_W;
            float disp_y = sy + SCREEN_R_H;
            new_scale = get_scale(&disp_x, &disp_y, new_scale, icon_w, icon_h);

            sx = disp_x - SCREEN_R_W;
            sy = disp_y - SCREEN_R_H;
            /* if (icon_p->index == 0){ */
            /* printf("step2:\n"); */
            /* put_float(new_scale); */
            /* put_float(correct_w_s); */
            /* put_float(correct_h_s); */
            /* g_flag = 0; */
            /* } */

            if (new_scale <= 0) {
                goto __disp_none;
            }

#if USE_DIFF_ICON
            new_scale = new_scale * step_scale;
#endif
            //新的缩放比例
            ratio = new_scale;

            //新的左上角坐标
            newx = (sx + SCREEN_R_W) - (icon_w * ratio) / 2;
            newy = (sy + SCREEN_R_H) - (icon_h * ratio) / 2;

            /* newx += 60; */
            /* newy += 60;	 */
            if (new_scale <= 0) {
                printf("new_scale err\n");
                put_float(new_scale);
                while (1);
            }


            //转换成SDK的参数
            elm->css.width = (icon_w * ratio) * 10000 / layout_rect.width;
            elm->css.height = (icon_h * ratio) * 10000 / layout_rect.height;
            elm->css.left = (newx - layout_rect.left) * 10000 / layout_rect.width;
            elm->css.top = (newy - layout_rect.top) * 10000 / layout_rect.height;
            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio;
            elm->css.ratio.ratio_h = ratio;

            /* int tmp; */
            /* if (ratio < 0.5) { */
            /* tmp = (int)(icon_w * ratio); */
            /* elm->css.ratio.ratio_w = (float)tmp / icon_w; */
            /* tmp = (int)(icon_h * ratio); */
            /* elm->css.ratio.ratio_h = (float)tmp / icon_h; */
            /* } */
            /* printf("%d, %d, %d, %d\n", elm->css.width, elm->css.height, elm->css.left, elm->css.top); */

        } else {

__disp_none:
            //转换成SDK的参数
            elm->css.width = 0;
            elm->css.height = 0;
            elm->css.left = 0;
            elm->css.top = 0;
            elm->css.ratio.en = 0;
            elm->css.ratio.ratio_w = 0;
            elm->css.ratio.ratio_h = 0;
        }
    }
}



int icon_change(struct list_head *root, struct element *layout_elm, int draw)
{
    struct rect layout_rect;
    int cx, cy;
    int s_icon;
    struct element *elm;
    struct element elm_mix;
    int limit = svi.icon_level - 1;
    struct icon_list *icon_core = svi.icon_core;
    struct rect icon_core_rect;
    struct icon_list *icon_p;
    float r0, r1, d0, tx, ty, ratio;
    int icon_core_ori_cx, icon_core_ori_cy;
    int icon_core_cx, icon_core_cy;
    int disx, disy;
    int angle;
    struct rect cur_rect;

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);

    /* printf("layout %d, %d, %d, %d\n", layout_rect.left, layout_rect.top, layout_rect.width, layout_rect.height); */

    if (icon_step == 0) {
        cx = layout_rect.left + layout_rect.width / 2;
        cy = layout_rect.top + layout_rect.height / 2;
        /* cx = SCREEN_W - cx + CX_OFFSET; */
        /* cy = SCREEN_H - cy + CY_OFFSET; */
        cx = in_W_inter - cx + CX_OFFSET;
        cy = in_H_inter - cy + CY_OFFSET;

#if USE_DIFF_ICON
        step_scale = 1;
#endif
        show_icon(root, layout_elm, cx, cy);
    } else {

#if USE_DIFF_ICON
        int step;
        int step_limit;

        step = icon_step;
        if (step < 0) {
            step = abs(step) - 1;
        } else {
            step = ICON_STEP_LIMIT + (step - 1);
        }
        step_limit = STEP_TAB_NUM - 1;
        step = (step > step_limit) ? step_limit : step;
        step_scale = step_scale_tab[step];

        cx = layout_rect.left + layout_rect.width / 2;
        cy = layout_rect.top + layout_rect.height / 2;
        cx = SCREEN_W - cx + CX_OFFSET;
        cy = SCREEN_H - cy + CY_OFFSET;

        show_icon(root, layout_elm, cx, cy);
#else

        if (icon_step < 0) {
            s_icon = abs(icon_step);
        } else {
            s_icon = 0;
        }
        s_icon = (s_icon > limit) ? limit : s_icon;
        s_icon = (s_icon < 0) ? 0 : s_icon;
        cx = svi.ics[s_icon].icon_w;
        cy = svi.ics[s_icon].icon_h;

        list_for_each_entry(icon_p, root, entry) {
            elm = icon_p->elm;
            elm->css.width = cx * 10000 / layout_rect.width;
            elm->css.height = cy * 10000 / layout_rect.height;
            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            ratio = (float)cx / icon_p->width;
            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio;
            elm->css.ratio.ratio_h = ratio;
        }
        /* ratio = ratio * 0.92; */

        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->elm->css.left;
        elm_mix.css.top = icon_core->elm->css.top;
        elm_mix.css.width = icon_core->elm->css.width;
        elm_mix.css.height = icon_core->elm->css.height;
        ui_core_get_element_abs_rect(&elm_mix, &icon_core_rect);

        icon_core_ori_cx = icon_core->left + icon_core->width / 2;
        icon_core_ori_cy = icon_core->top + icon_core->height / 2;
        icon_core_cx = icon_core_rect.left + icon_core_rect.width / 2;
        icon_core_cy = icon_core_rect.top + icon_core_rect.height / 2;

        list_for_each_entry(icon_p, root, entry) {

            if (icon_p == icon_core) {
                continue;
            }

            elm_mix.parent = icon_p->elm->parent;
            elm_mix.css.left = icon_p->elm->css.left;
            elm_mix.css.top = icon_p->elm->css.top;
            elm_mix.css.width = icon_p->elm->css.width;
            elm_mix.css.height = icon_p->elm->css.height;
            ui_core_get_element_abs_rect(&elm_mix, &cur_rect);

            r1 = cur_rect.width / 2;
            r0 = icon_p->width / 2;
            cx = icon_p->left + r0;
            cy = icon_p->top + r0;
            disx = abs(cx - icon_core_ori_cx);
            disy = abs(cy - icon_core_ori_cy);
            d0 = complex_abs_float((float)disx, (float)disy);

            d0 = d0 * (r1 / r0) + 0.5;
            angle = get_angle(cx - icon_core_ori_cx, cy - icon_core_ori_cy);

            tx = cos_float(angle / 180.f) * d0;
            ty = sin_float(angle / 180.f) * d0;

            if ((angle >= 270) || (angle <= 90)) {
                cx = icon_core_cx + abs(tx) - r1 - 1;
            } else {
                cx = icon_core_cx - abs(tx) - r1 + 1;
            }
            if ((angle >= 0) && (angle <= 180)) {
                cy = icon_core_cy + abs(ty) - r1 - 1;
            } else {
                cy = icon_core_cy - abs(ty) - r1 + 1;
            }

            icon_p->elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
            icon_p->elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;

            /* icon_p->elm->css.ratio.ratio_w = ratio; */
            /* icon_p->elm->css.ratio.ratio_h = ratio; */
        }

#endif//#if USE_DIFF_ICON

    }

    if (draw) {
        ui_core_redraw(elm);
    }

    return 0;
}

#endif//end #if (SVI_USE_NORMAL)

static int MOVING_1_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct layout *layout = (struct layout *)_ctrl;
    struct element *p;
    struct rect rect;
    struct icon_list *icon_p;
    struct icon_list *n;
    int index;

#if TCFG_PSRAM_UI_EFFECT
    struct element *win_elm = layout->elm.parent;
    static struct effect_sca_alpha sal = {0};
    static struct effect_3d s3d = {0};
#endif

    switch (event) {
    case ON_CHANGE_INIT:
        /* key_ui_takeover(1); */

#if TCFG_PSRAM_UI_EFFECT
        sal.sca = 0.8;
        sal.alpha = 67;

        s3d.focal = 500;
        /* ui_window_effect(win_elm->id, EFFECT_MODE_SCA, NULL, NULL); */
        /* ui_window_effect(win_elm->id, EFFECT_MODE_3D, NULL, NULL); */
        /* ui_window_effect(win_elm->id, EFFECT_MODE_SCA_ALPHA, NULL, NULL); */
#endif

        startlight_svi_init();

        index = 0;

        list_for_each_child_element(p, &layout->elm) {
            ui_core_get_element_abs_rect(p, &rect);

            struct icon_list *icon = (struct icon_list *)zalloc(sizeof(struct icon_list));
            icon->index = index++;
            icon->size = -1;
            icon->elm = p;

            icon->css_left = p->css.left;
            icon->css_top = p->css.top;
            icon->css_width = p->css.width;
            icon->css_height = p->css.height;

            icon->left = rect.left;
            icon->right = rect.left + rect.width - 1;
            icon->top = rect.top;
            icon->bottom = rect.top + rect.height - 1;

            icon->width = rect.width;
            icon->height = rect.height;
            icon->cx = icon->left + rect.width / 2;
            icon->cy = icon->top + rect.height / 2;
            list_add_tail(&icon->entry, &icon_root);

            if (icon->index == 0) {//这意味着，UI布局时必须将第一个图标放到屏幕中心
                svi.icon_core = icon;
            }
            printf("index: %d, %d, %d, %d, %d\n", icon->index, icon->left, icon->top, icon->width, icon->height);
        }

        //先恢复布局坐标再调icon_change,调用顺序不能改
        startlight_scene_recover(layout, &icon_root);

        icon_change(&icon_root, &layout->elm, false);

        break;

    case ON_CHANGE_RELEASE:
        /* key_ui_takeover(0); */

        startlight_scene_save(layout, &icon_root);

        list_for_each_entry_safe(icon_p, n, &icon_root, entry) {
            struct element *elm = icon_p->elm;
            elm->css.left = icon_p->css_left;
            elm->css.top = icon_p->css_top;
            elm->css.width = icon_p->css_width;
            elm->css.height = icon_p->css_height;
            list_del(&icon_p->entry);
            free(icon_p);
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

static int MOVING_1_ontouch(void *ctrl, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)ctrl;
    struct element *p;
    struct rect rect;
    static struct position pos = {0};
    int diff_x, diff_y;
    static struct rect orig = {0};
    struct icon_list *icon_p;

    switch (e->event) {

    case ELM_EVENT_TOUCH_DOWN:
        icon_tstatus = 0;
        /* printf("TOUCH DOWN:(%d,%d)\n",e->pos.x,e->pos.y); */
        pos.x = e->pos.x;
        pos.y = e->pos.y;

        icon_change(&icon_root, &layout->elm, false);
        ui_core_redraw(layout->elm.parent);

        orig.left = layout->elm.css.left;
        orig.top = layout->elm.css.top;
        orig.width = layout->elm.css.width;
        orig.height = layout->elm.css.height;
        break;

    case ELM_EVENT_TOUCH_UP:
        printf("touch up moving\n");
        break;

    case ELM_EVENT_TOUCH_MOVE:
        ui_io_set(IO_FRAME, HIGH);

        int tw, th;
        int tleft, ttop;
        tleft = layout->elm.css.left;
        ttop = layout->elm.css.top;

        diff_x = e->pos.x - pos.x;
        diff_y = e->pos.y - pos.y;

        layout->elm.css.left = orig.left;
        layout->elm.css.top = orig.top;
        layout->elm.css.width = orig.width;
        layout->elm.css.height = orig.height;
        ui_core_get_element_abs_rect(&layout->elm, &rect);

        rect.left += diff_x;
        rect.top += diff_y;

#if 0
        tw = (rect.width - svi.lcd_w) / 2 + rect.left;//虚拟的屏幕左上角0点(假设会动)
        th = (rect.height - svi.lcd_h) / 2 + rect.top;//虚拟的屏幕左上角0点(假设会动)
        tw = abs(svi.lcd_w - abs(tw));//0点超过屏幕左上角原点(不会动)的距离
        th = abs(svi.lcd_h - abs(th));//0点超过屏幕左上角原点(不会动)的距离
        /* printf("lt %d, %d\n", tw, th); */
        //这里限制全部滑出,根据需要调整!!!
        if ((tw < svi.lcd_w / 4) || (th < svi.lcd_h / 4)) {
            layout->elm.css.left = tleft;
            layout->elm.css.top = ttop;
            break;
        }
#endif

        layout->elm.css.left = rect.left * 10000 / svi.lcd_w;
        layout->elm.css.top = rect.top * 10000 / svi.lcd_h;

        icon_change(&icon_root, &layout->elm, false);

        ui_core_redraw(layout->elm.parent);

        ui_io_set(IO_FRAME, LOW);

        icon_tstatus = 2;
        break;

    default:
        break;
    }
    return true;
}

int ui_star_move_check(void)
{
    if (icon_tstatus) {
        return true;
    }
    return false;
}

#if 1

static int test_page_onkey(void *ctr, struct element_key_event *e)
{
    struct layout *layout = (struct layout *)ctr;
#if USE_DIFF_ICON
    int limit = ICON_STEP_LIMIT;
    int flag = 0;
    struct icon_list *icon_core = NULL;
    struct rect rect;
    int org_cx, org_cy;
    int new_cx, new_cy;
#else
    int limit = svi.icon_level - 1;
#endif

    switch (e->value) {
    case KEY_OK:
        printf("skey_ok\n");
        break;
    /* case KEY_UI_DOWN: */
    case KEY_UI_MINUS:
    case KEY_UI_HOME:

        icon_step--;
#if USE_DIFF_ICON
        if (icon_step < -limit) {
            icon_step = -limit;
            flag = 1;
        }

        if (!flag) {
            ui_core_get_element_abs_rect(svi.icon_core->elm, &rect);
            if (rect.width) {
                org_cx = rect.left + rect.width / 2;
                org_cy = rect.top + rect.height / 2;
                icon_core = svi.icon_core;
            }
        }
#else
        if (icon_step < -limit) {
            icon_step = -limit;
        }
#endif
        printf("skey_down %d\n", icon_step);

        icon_change(&icon_root, &layout->elm, false);

#if USE_DIFF_ICON
        if ((!flag) && icon_core) {
            ui_core_get_element_abs_rect(icon_core->elm, &rect);
            if (rect.width) {
                new_cx = rect.left + rect.width / 2;
                new_cy = rect.top + rect.height / 2;

                ui_core_get_element_abs_rect(&layout->elm, &rect);
                rect.left += (org_cx - new_cx);
                rect.top += (org_cy - new_cy);
                layout->elm.css.left = rect.left * 10000 / svi.lcd_w;
                layout->elm.css.top = rect.top * 10000 / svi.lcd_h;
                icon_change(&icon_root, &layout->elm, false);
            }
        }
#endif

        ui_core_redraw(layout->elm.parent);
        printf("skey_down out\n");
        break;
    /* case KEY_UI_UP: */
    case KEY_UI_PLUS:
    case KEY_UI_SHORTCUT:
        icon_step++;
#if USE_DIFF_ICON
        if (icon_step > limit) {
            icon_step = limit;
            flag = 1;
        }

        if (!flag) {
            ui_core_get_element_abs_rect(svi.icon_core->elm, &rect);
            if (rect.width) {
                org_cx = rect.left + rect.width / 2;
                org_cy = rect.top + rect.height / 2;
                icon_core = svi.icon_core;
            }
        }
#else
        if (icon_step > 1) {
            icon_step = 1;
        }
#endif
        printf("skey_up %d\n", icon_step);

        icon_change(&icon_root, &layout->elm, false);

#if USE_DIFF_ICON
        if ((!flag) && icon_core) {
            ui_core_get_element_abs_rect(icon_core->elm, &rect);
            if (rect.width) {
                new_cx = rect.left + rect.width / 2;
                new_cy = rect.top + rect.height / 2;

                ui_core_get_element_abs_rect(&layout->elm, &rect);
                rect.left += (org_cx - new_cx);
                rect.top += (org_cy - new_cy);
                layout->elm.css.left = rect.left * 10000 / svi.lcd_w;
                layout->elm.css.top = rect.top * 10000 / svi.lcd_h;
                icon_change(&icon_root, &layout->elm, false);
            }
        }
#endif

        ui_core_redraw(layout->elm.parent);
        printf("skey_up out\n");
        break;
    default:
        return false;
    }
    return false;
}
#endif

REGISTER_UI_EVENT_HANDLER(MOVING_1)
.onchange = MOVING_1_onchange,
 /* .onkey = NULL,//test_page_onkey, */
 .onkey = test_page_onkey,
  .ontouch = MOVING_1_ontouch,
};


/************************************ startlight end *************************/



#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO

const u8 icon_48x49_rgb565[4704] = {//format:r5g3 g3b5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x20, 0x60, 0x28, 0x81,
    0x28, 0x81, 0x20, 0x60, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x40, 0xE1, 0x81, 0xC3, 0xB2, 0x65, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0xB2, 0x65, 0x81, 0xC3, 0x40, 0xE1, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA1, 0x9A, 0x04,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE3, 0x06,
    0x9A, 0x04, 0x30, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xC1, 0xB2, 0x64, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xB2, 0x64, 0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0xA2, 0x04, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xA2, 0x04, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0xE1, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x40, 0xE1, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x79, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x79, 0x83,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0xE3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0x91, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0xE3, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0x89, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x83, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0x71, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC1, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xCA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA,
    0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0x67, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x40, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xDA, 0xC5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xF3, 0xC9, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xC5, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0xE3, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x91, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x28, 0x81, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x28, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xA2, 0x24, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x60, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFE, 0x15, 0xFD, 0xB3,
    0xFD, 0xD4, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x20, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x79, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xFF, 0xFE, 0x15, 0xF4, 0x4C, 0xF5, 0x31, 0xFE, 0x36, 0xFE, 0x98,
    0xFE, 0x77, 0xFD, 0xB3, 0xF4, 0x8D, 0xF5, 0x10, 0xFF, 0x9D, 0xFE, 0x15, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x79, 0xA3, 0x00, 0x00,
    0x00, 0x00, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xF4, 0x6C, 0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xF4, 0xAE, 0xFE, 0x36, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3B, 0xF4, 0xCF, 0xF4, 0x4C, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xEA, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x00, 0x00,
    0x20, 0x80, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xF4, 0xFF, 0x3B, 0xF5, 0x10, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xAE, 0xFF, 0xFF, 0xFD, 0xB3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x20, 0x80,
    0x61, 0x42, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xB4, 0xFF, 0x9E, 0xFF, 0x5C, 0xF4, 0xCF, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x51, 0xF4, 0x0B,
    0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xDE, 0xFF, 0xFF, 0xFD, 0x92,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x61, 0x42,
    0x91, 0xE4, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xA9, 0xFD, 0xF5, 0xFF, 0xDF, 0xFF, 0x3B, 0xF4, 0x8E, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3,
    0xFE, 0xFA, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0xBE, 0xFF, 0xFF, 0xFD, 0xF5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x91, 0xE4,
    0xBA, 0x64, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x68, 0xFD, 0x72, 0xFF, 0xBE, 0xFF, 0x7C, 0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x6D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA,
    0xF5, 0x10, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x77,
    0xF3, 0xA9, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xBA, 0x64,
    0xD2, 0xC5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF5, 0x31, 0xFF, 0x5C, 0xFF, 0x9D, 0xF5, 0x51, 0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x36,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68,
    0xF3, 0xCA, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF5, 0x31, 0xFF, 0xFF, 0xFF, 0xDF, 0xF4, 0x8D,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xD2, 0xC5,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68, 0xF3, 0xCA,
    0xFF, 0x7D, 0xFF, 0xFF, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF4, 0x8D, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x68, 0xFF, 0x9D, 0xFF, 0xFF, 0xFE, 0xB9,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE3, 0x06,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF4, 0x6C, 0xFE, 0xD9, 0xFF, 0xDE, 0xFE, 0x57, 0xF3, 0xEA, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68, 0xF3, 0xCA, 0xFF, 0x7D,
    0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x47, 0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0x5C, 0xF3, 0x88,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x47, 0xF5, 0x10, 0xFF, 0xBE, 0xFF, 0x9D, 0xFD, 0x51, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x88, 0xF3, 0xCA, 0xFF, 0x7C, 0xFF, 0xFF,
    0xFD, 0x72, 0xF3, 0x26, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xFD, 0x51, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0x4C, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26,
    0xE2, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF4, 0x6C, 0xFE, 0xD9, 0xFF, 0xDE, 0xFE, 0x57, 0xF3, 0xEA, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x98, 0xFF, 0x7D, 0xFF, 0xFF, 0xFD, 0x72,
    0xF3, 0x26, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF4, 0x8D, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x47, 0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0x5C, 0xF3, 0x88,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE2, 0xE6,
    0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x56,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xD4, 0xF3, 0x26,
    0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x68, 0xFF, 0x9D, 0xFF, 0xFF, 0xFE, 0xB9,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5,
    0xAA, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF5, 0x31, 0xFF, 0x5C, 0xFF, 0x9D, 0xF5, 0x51, 0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x8D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x16, 0xFD, 0x72,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x78,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF5, 0x31, 0xFF, 0xFF, 0xFF, 0xDF, 0xF4, 0x8D,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xAA, 0x24,
    0x81, 0xA3, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x68, 0xFD, 0x72, 0xFF, 0xBE, 0xFF, 0x7C, 0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10,
    0xFE, 0x98, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x81, 0xA3,
    0x49, 0x02, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xA9, 0xFD, 0xF5, 0xFF, 0xDF, 0xFF, 0x3B, 0xF4, 0x8E, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF4, 0xCF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0xBE, 0xFF, 0xFF, 0xFD, 0xF5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x49, 0x02,
    0x08, 0x20, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xB4, 0xFF, 0x9E, 0xFF, 0x5C, 0xF4, 0xCF, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x2B, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xDE, 0xFF, 0xFF, 0xFD, 0x92,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x08, 0x20,
    0x00, 0x00, 0xB2, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xF4, 0xFF, 0x3B, 0xF5, 0x10, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xF4, 0xCF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0xF0, 0xF4, 0x6D, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xAE, 0xFF, 0xFF, 0xFD, 0xB3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xB2, 0x44, 0x00, 0x00,
    0x00, 0x00, 0x59, 0x22, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xF4, 0x6C, 0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xFF, 0xFE, 0x15, 0xF4, 0x6D, 0xFD, 0x72, 0xFE, 0x57, 0xFE, 0xB9,
    0xFE, 0x98, 0xFD, 0xD4, 0xF4, 0xAE, 0xF5, 0x31, 0xFF, 0x9D, 0xFE, 0x15, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xEA, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x59, 0x22, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x00, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1A, 0xFE, 0x15, 0xFD, 0xB3,
    0xFD, 0xD4, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x71, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x71, 0x83, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x22, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x59, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9D, 0xF3, 0xA9, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xAA, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0xD2, 0xC5, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xC9, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA,
    0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0x67, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xD2, 0xC5, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA1, 0xE3, 0x06, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xE3, 0x06, 0x30, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE1, 0xEB, 0x06,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xEB, 0x06, 0x40, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC1,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE2, 0xE6,
    0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x81, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x28, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x20, 0x9A, 0x04, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x9A, 0x04, 0x08, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xE2, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x48, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x42, 0xCA, 0xA5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xCA, 0xA5, 0x59, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xC1,
    0x91, 0xE4, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x91, 0xE4,
    0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x28, 0x81, 0x59, 0x22, 0x81, 0xA3, 0xA2, 0x24, 0xBA, 0x65, 0xC2, 0x85,
    0xC2, 0x85, 0xBA, 0x65, 0xA2, 0x24, 0x81, 0xA3, 0x59, 0x22, 0x28, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const u8 icon_48x49_argb8565[7056] = {//format:a8 r5g3 g3b5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
    0xEB, 0x07, 0x22, 0xF3, 0x46, 0x2B, 0xF3, 0x26, 0x2B, 0xF3, 0x26, 0x22, 0xF3, 0x46, 0x0D, 0xFB,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0xFB, 0x08, 0x4A, 0xF3, 0x26, 0x8B, 0xF3, 0x26, 0xC1, 0xF3, 0x26, 0xEC, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xEC, 0xF3, 0x26, 0xC1, 0xF3, 0x26, 0x8B, 0xF3, 0x26, 0x4A, 0xF3, 0x26, 0x08, 0xFB, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xF3, 0x26, 0xA0, 0xF3, 0x26,
    0xF2, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF2, 0xF3, 0x26,
    0xA0, 0xF3, 0x26, 0x38, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3E, 0xF3, 0x26, 0xBD, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xBD, 0xF3, 0x26, 0x3E, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xF3,
    0x46, 0xAB, 0xF3, 0x26, 0xFE, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFE, 0xF3, 0x26, 0xAB, 0xF3, 0x26, 0x19,
    0xEB, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xF3, 0x26, 0xEB, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEB,
    0xF3, 0x26, 0x48, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF3, 0x26, 0xFD, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFD, 0xF3, 0x26, 0x80, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0xFC, 0x00, 0x99, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x9A, 0xF3, 0x26, 0x01, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x97, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x96, 0xF3, 0x26, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x78, 0xF3,
    0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xF3, 0x26, 0xFC,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xEA, 0xFF,
    0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3,
    0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x67, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3,
    0x26, 0x44, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xEB, 0x06, 0xE5, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xFF, 0xF3, 0xC9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xE5, 0xF3, 0x26, 0x10, 0xEB, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0x98, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0xF3, 0x46, 0xFC, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0x2C, 0xF3, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xAA, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x21, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xFA, 0xFF, 0xFE, 0x15, 0xFF, 0xFD, 0xB3, 0xFF, 0xFD, 0xD4, 0xFF, 0xFE, 0x98, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0x22, 0xF3, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x83, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x15, 0xFF, 0xF4, 0x4C, 0xFF,
    0xF5, 0x31, 0xFF, 0xFE, 0x36, 0xFF, 0xFE, 0x98, 0xFF, 0xFE, 0x77, 0xFF, 0xFD, 0xB3, 0xFF, 0xF4,
    0x8D, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0x9D, 0xFF, 0xFE, 0x15, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x83, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xDA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF4, 0x6C, 0xFF, 0xF3,
    0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xF4, 0xAE, 0xFF, 0xFE, 0x36, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0xCF, 0xFF, 0xF4, 0x4C, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x27, 0xF3, 0x46, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xF4, 0xFF, 0xFF, 0x3B, 0xFF, 0xF5,
    0x10, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF4, 0xAE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x27, 0xF3, 0x46,
    0x66, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xB4, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0xCF, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0xC9, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x51, 0xFF, 0xF4, 0x0B,
    0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF,
    0xFF, 0xDE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x66, 0xF3, 0x26,
    0x9A, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFD, 0xF5, 0xFF, 0xFF,
    0xDF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0x8E, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3,
    0xFF, 0xFE, 0xFA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0xBE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xF5, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x9A, 0xF3, 0x26,
    0xC3, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF, 0xFD, 0x72, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x7C, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x77,
    0xFF, 0xF3, 0xA9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xC3, 0xF3, 0x26,
    0xE1, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF,
    0x9D, 0xFF, 0xF5, 0x51, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x36,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE1, 0xF3, 0x26,
    0xF4, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xFA, 0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0x98, 0xFF, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF,
    0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xB9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF4, 0xF3, 0x26,
    0xFD, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6C, 0xFF, 0xFE, 0xD9, 0xFF, 0xFF,
    0xDE, 0xFF, 0xFE, 0x57, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF,
    0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3,
    0x26, 0xFF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xFE, 0xB9, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFD, 0xF3, 0x26,
    0xFA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xF5, 0x10, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x9D, 0xFF, 0xFD, 0x51, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x88, 0xFF,
    0xF3, 0xCA, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF5,
    0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0x51, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF4, 0x4C, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFA, 0xF3, 0x26,
    0xEE, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6C, 0xFF, 0xFE, 0xD9, 0xFF, 0xFF,
    0xDE, 0xFF, 0xFE, 0x57, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x98, 0xFF,
    0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x10, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xFE, 0xD9, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEE, 0xF3, 0x26,
    0xD7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x56,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xD4, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF,
    0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xB9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xD7, 0xF3, 0x26,
    0xB5, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF,
    0x9D, 0xFF, 0xF5, 0x51, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x8D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFE, 0x16, 0xFF, 0xFD, 0x72, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x78,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xB5, 0xF3, 0x26,
    0x88, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF, 0xFD, 0x72, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x7C, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10,
    0xFF, 0xFE, 0x98, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x88, 0xF3, 0x26,
    0x50, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFD, 0xF5, 0xFF, 0xFF,
    0xDF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0x8E, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0xC9, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF4, 0xCF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0xBE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xF5, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x50, 0xF3, 0x26,
    0x10, 0xEB, 0x06, 0xFB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xB4, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0xCF, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x2B, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF,
    0xFF, 0xDE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFB, 0xF3, 0x26, 0x10, 0xEB, 0x06,
    0x00, 0x00, 0x00, 0xBB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xF4, 0xFF, 0xFF, 0x3B, 0xFF, 0xF5,
    0x10, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xF4, 0xCF, 0xFF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF4, 0xF0, 0xFF, 0xF4, 0x6D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF4, 0xAE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xBB, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x5F, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF4, 0x6C, 0xFF, 0xF3,
    0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x15, 0xFF, 0xF4, 0x6D, 0xFF,
    0xFD, 0x72, 0xFF, 0xFE, 0x57, 0xFF, 0xFE, 0xB9, 0xFF, 0xFE, 0x98, 0xFF, 0xFD, 0xD4, 0xFF, 0xF4,
    0xAE, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x9D, 0xFF, 0xFE, 0x15, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x5F, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x09, 0xE2, 0xA7, 0xEA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x1A, 0xFF, 0xFE, 0x15, 0xFF, 0xFD, 0xB3, 0xFF, 0xFD, 0xD4, 0xFF, 0xFE, 0x98, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEA, 0xF3, 0x26, 0x09, 0xE2, 0xA7, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x7C, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0xEB, 0x07, 0xE7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xE7, 0xF3, 0x26, 0x0D, 0xEB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0x5F, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9D, 0xFF, 0xF3, 0xA9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xB4, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF3, 0x06, 0xE2,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF3, 0xCA, 0xFF,
    0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3,
    0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0x67, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE3, 0xF3,
    0x26, 0x15, 0xF3, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34,
    0xF3, 0x26, 0xF3, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF3, 0xF3, 0x26, 0x34, 0xF3,
    0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x46, 0xF3, 0x26, 0xF7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF7, 0xF3, 0x26, 0x45, 0xF3, 0x26, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xF3, 0x26, 0xF1, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEF, 0xF3, 0x26, 0x3E, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0xF3, 0x26, 0xDA, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xDA, 0xF3, 0x26, 0x2D, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0xEB, 0x07, 0xA4, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xA4,
    0xF3, 0x26, 0x0D, 0xFB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x4C, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0x4C, 0xF3, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0xCB, 0x26, 0x64, 0xF3, 0x26, 0xD7, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xD7, 0xF3, 0x26, 0x64, 0xF3, 0x26, 0x05, 0xCB, 0x26, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x41, 0xF3, 0x26,
    0x9B, 0xF3, 0x26, 0xE8, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE8, 0xF3, 0x26, 0x9B, 0xF3, 0x26,
    0x41, 0xF3, 0x26, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x2B, 0xFB, 0x26, 0x62, 0xF3, 0x26, 0x8D, 0xF3, 0x26, 0xAD,
    0xF3, 0x26, 0xC2, 0xF3, 0x26, 0xCC, 0xF3, 0x26, 0xCC, 0xF3, 0x26, 0xC2, 0xF3, 0x26, 0xAD, 0xF3,
    0x26, 0x8D, 0xF3, 0x26, 0x62, 0xF3, 0x26, 0x2C, 0xF3, 0x46, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


#define DRAW_IMAGE              0x0
#define DRAW_IMAGE_WITH_ALPHA   0x1

struct image_buf {
    u8 *buf;
    u32 len;
};

static void ui_custom_draw_cb(int id, u8 *dst_buf, struct rect *dst_r, struct rect *src_r, u8 bytes_per_pixel, void *priv)
{
    int w, h;
    struct rect r;
    struct draw_context dc = {0};

    if (id == DRAW_IMAGE) {
        int dst_stride = (dst_r->width * bytes_per_pixel + 3) / 4 * 4;
        int src_stride = (src_r->width * bytes_per_pixel + 3) / 4 * 4;
        struct image_buf *image_b = (struct image_buf *)priv;
        /* printf("ui_custom_draw_cb 0x%x, %d\n", image_b->buf, image_b->len); */
        /* printf("dst [%d, %d, %d, %d],  src [%d, %d, %d, %d]\n", dst_r->left, dst_r->top, dst_r->width, dst_r->height, */
        /* src_r->left, src_r->top, src_r->width, src_r->height); */

        if (get_rect_cover(src_r, dst_r, &r)) {
            for (h = 0; h < r.height; h++) {
                memcpy(&dst_buf[(r.top + h - dst_r->top) * dst_stride + (r.left - dst_r->left) * 2],
                       &image_b->buf[(r.top + h - src_r->top) * src_stride + (r.left - src_r->left) * 2],
                       r.width * 2);
            }
        }
    } else if (id == DRAW_IMAGE_WITH_ALPHA) {
        int dst_stride = (dst_r->width * bytes_per_pixel + 3) / 4 * 4;
        /* int src_stride = (src_r->width * 3 + 3) / 4 * 4; */
        struct image_buf *image_b = (struct image_buf *)priv;
        u8 alpha;
        u16 forecolor;
        u16 backcolor;
        u16 mixedcolor;
        u32 offset_src;
        u32 offset_dst;

        if (get_rect_cover(src_r, dst_r, &r)) {
            for (h = 0; h < r.height; h++) {
                for (w = 0; w < r.width; w++) {
                    offset_src = (r.top + h - src_r->top) * src_r->width * 3 + (r.left + w - src_r->left) * 3;
                    alpha = image_b->buf[offset_src];
                    forecolor = (image_b->buf[offset_src + 1] << 8) | image_b->buf[offset_src + 2];

                    if (alpha) {
                        offset_dst = (r.top + h - dst_r->top) * dst_stride + (r.left + w - dst_r->left) * 2;
                        backcolor = (dst_buf[offset_dst + 1] << 8) | dst_buf[offset_dst];
                        mixedcolor = ui_draw_get_mixed_pixel((backcolor >> 8) | ((backcolor & 0xff) << 8), forecolor, alpha);
                        dst_buf[offset_dst] = mixedcolor;
                        dst_buf[offset_dst + 1] = mixedcolor >> 8;
                    }
                }
            }
        }
    }
}


void ui_draw_custom_rgb565(void *_dc, int x, int y, int width, int height, u8 *buf, u32 len)
{
    struct image_buf image_b;
    image_b.buf = buf;
    image_b.len = len;
    /* printf("ui_draw_custom_rgb565 0x%x, %d\n", image_b.buf, image_b.len); */
    ui_draw(_dc, NULL, x, y, width, height, ui_custom_draw_cb, &image_b, sizeof(struct image_buf), DRAW_IMAGE);
}

void ui_draw_custom_argb8565(void *_dc, int x, int y, int width, int height, u8 *buf, u32 len)
{
    struct image_buf image_b;
    image_b.buf = buf;
    image_b.len = len;
    /* printf("ui_draw_custom_argb8565 0x%x, %d\n", image_b.buf, image_b.len); */
    ui_draw(_dc, NULL, x, y, width, height, ui_custom_draw_cb, &image_b, sizeof(struct image_buf), DRAW_IMAGE_WITH_ALPHA);
}

#endif

/*
 * 说明：自定义绘图适用于所有控件，这里示例选用布局
 * */
static int DRAW_DEMO_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct element *elm = (struct element *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    struct rect rect = {0};
    struct rect r = {0};
    struct image_file f;
    struct rect r1;
    int angle;
    int id;
    int i;

    switch (event) {
    case ON_CHANGE_INIT:
        break;
    case ON_CHANGE_SHOW:
#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO
        /*根据需要调用以下三个接口:ui_remove_backcolor,ui_remove_backimage,ui_remove_border*/
        ui_remove_backcolor(elm);//移除控件背景颜色
        ui_remove_backimage(elm);//移除控件背景图像
        ui_remove_border(elm);//移除控件边界
#endif
        break;
    case ON_CHANGE_SHOW_POST:
#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO
        ui_custom_draw_clear(dc);

        ui_core_get_element_abs_rect(elm->dc->elm, &r); //跟随控件移动,注释掉这句则不跟随控件移动
        ui_core_get_element_abs_rect(elm, &rect); //跟随控件移动,注释掉这句则不跟随控件移动
        rect.left -= r.left;
        rect.top -= r.top;

        /*
         * 以下绘图函数只能在该控件的范围内显示，超出控件区域不显示
         * */

        /* 矩形填充 */
        ui_fill_rect(dc, 100, 100, 254, 254, 0xffff);

        /* 指定角度画直线  */
        for (angle = 0; angle <= 360; angle += 45) {
            ui_draw_line_by_angle(dc, 227, 227, 100, angle, 0xf800);
        }

        /* 画矩形 */
        ui_draw_rect(dc, 125, 125, 204, 204, 0xf800);

        /* 画线段 */
        ui_draw_line(dc, 120, 120, 333, 120, 0x07e0);
        ui_draw_line(dc, 333, 120, 333, 333, 0x07e0);
        ui_draw_line(dc, 333, 333, 120, 333, 0x07e0);
        ui_draw_line(dc, 120, 333, 120, 120, 0x07e0);

        /* 画圆 */
        ui_draw_ring(dc, 227, 227, 102, 90, 0, 360, 0x003f, 100);

        /* 画圆环 */
        ui_draw_ring(dc, 227, 227, 117, 105, 0 + 135, 270 + 135, 0xc618, 100);
        ui_draw_ring(dc, 227, 227, 117, 105, 0 + 135, 270 + 135, 0xf800, 75);

        /* 画进度条 */
        ui_draw_bar(dc, 120, 380, 200, 25, RGB565(58, 63, 72), 100);
        ui_draw_bar(dc, 120, 380, 200, 25, 0xf800, 50);

        /* 显示缓存叠加图片 */
        ui_draw_custom_rgb565(dc, rect.left + 100, rect.top + 100, 48, 49, icon_48x49_rgb565, sizeof(icon_48x49_rgb565));

        /* 显示缓存叠加图片(带alpha) */
        ui_draw_custom_argb8565(dc, rect.left + 220, rect.top + 100, 48, 49, icon_48x49_argb8565, sizeof(icon_48x49_argb8565));

        /* 显示图片id到指定坐标 */
        id = PAGE17_3ec1_01_MENU_ICON_TRAINING_SEL_S5;
        open_image_by_id(0, NULL, &f, id & 0xffff, id >> 16);
        ui_draw_image(dc, id >> 16, id & 0xffff, (r.width - f.width) / 2, (r.height - f.height) / 2); //屏幕居中显示

        /* 显示多国语言文本 */
        ui_draw_strpic(dc, M26, 200, 280, RGB565(0, 0, 0));

        /* 显示ascii文本 */
        char *ascii = "0123456789";
        ui_draw_ascii(dc, ascii, strlen(ascii), 200, 296, RGB565(255, 0, 0));

        /* 显示字库文本 */
        char *text = "字库文本测试";
        ui_draw_text(dc, FONT_ENCODE_UTF8, 0, text, strlen(text), 200, 322, RGB565(255, 0, 0));
#endif
        break;

    case ON_CHANGE_RELEASE:
        break;
    default:
        break;
    }
    return false;
}

static int DRAW_DEMO_ontouch(void *_ctrl, struct element_touch_event *e)
{
    struct element *elm = (struct element *)_ctrl;
    struct rect rect;
    static struct position mem_pos = {0};
    int x_offset;
    int y_offset;
    int css_left;
    int css_top;
    struct element_css *css;

    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        memcpy(&mem_pos, &e->pos, sizeof(struct position));
        return true;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        x_offset = e->pos.x - mem_pos.x;
        y_offset = e->pos.y - mem_pos.y;
        memcpy(&mem_pos, &e->pos, sizeof(struct position));
        ui_core_get_element_abs_rect(elm->parent, &rect);
        css_left = x_offset * 10000 / rect.width;
        css_top = y_offset * 10000 / rect.height;
        css = ui_core_get_element_css(elm);
        css->left += css_left;
        css->top += css_top;
        ui_core_redraw(elm->parent);
        break;
    case ELM_EVENT_TOUCH_UP:
        break;
    }
    return false;
}

REGISTER_UI_EVENT_HANDLER(DRAW_DEMO)
.onchange = DRAW_DEMO_onchange,
 .onkey = NULL,
  .ontouch = DRAW_DEMO_ontouch,
};
#if 0
#include "ui_draw/ui_line.h"
#include "ui_draw/ui_figure.h"
static int newline_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct layout *layout = (struct layout *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    switch (event) {

    case ON_CHANGE_SHOW_POST:
        struct rect rect;
        ui_core_get_element_abs_rect(&layout->elm, &rect);
        struct rect *coords_rect;
        ui_style_list_t *style;
        newline_info_t line_info;
        static ui_point_t point_a[] = {{100, 100}, {150, 200}, {200, 100}, {250, 200}, {300, 200}}; //这里必须静态或者全局
        coords_rect = &line_info.coords_rect;
        style = &line_info.style;
        /******* 头文件有注释 ********/
        line_info.point_array = &point_a;//在画线框内的点坐标数组，每个点的坐标是相对coords_rect坐标来说的,该数组必须是全局或者静态
        line_info.point_num = sizeof(point_a) / sizeof(point_a[0]);//点的个数, 至少要有两个点
        style->line_width = 10;//画线时最小值可以为1
        style->line_color = UI_COLOR_ZI;
        coords_rect->left = 0;//相对背景的绝对坐标
        coords_rect->top = 0;//相对背景的绝对坐标
        coords_rect->width = 454;//该控件范围
        coords_rect->height = 454;//该控件范围

        printf("point_num %d\n", line_info.point_num);
        /*背景不是屏幕，一个页面只有一个背景，是最底的那一层，*/
        /*滑动时当前页面的背景在移动，但背景内的控件,相对背景是没有动的*/
        ui_draw(dc,
                NULL,
                coords_rect->left,//这里要写相对背景的绝对坐标
                coords_rect->top,//这里要写相对背景的绝对坐标
                coords_rect->width,
                coords_rect->height,
                ui_draw_default,
                (void *)&line_info,
                sizeof(newline_info_t),
                DRAW_SMOOTH_LINE);
        break;
    }

    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(TEST_LINE)
.onchange =  newline_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif

#if 0
#define ui_text_for_id(id) \
	({ \
		struct element *elm = ui_core_get_element_by_id(id); \
	 	elm ? container_of(elm, struct ui_text, elm): NULL; \
	 })
#define ui_number_for_id(id) \
    ({ \
        struct element *elm = ui_core_get_element_by_id(id); \
        elm ? (struct ui_number *)elm: NULL; \
     })

static int TEXT_TEST_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct ui_text *text = (struct ui_text *)ctr;
    static u8 time = 0;
    static u8 hour[24];
    static u8 num[24];
    static struct unumber n1, n2, n3;    //数字显示源

    //int language;
    switch (e) {
    case ON_CHANGE_INIT:
        /* ui_language_set(Arabic); */
        ui_language_set(Vietnam);
        //language = ui_language_get();
        ui_text_set_text_attrs(text, (char *)utf8_code, sizeof(utf8_code), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        time++;
        n1.type = TYPE_NUM;
        n1.numbs = 1;
        n1.number[0] = rand32() % 100; //未读传感器值，这里用随机数代替，取余获取较小数值
        n2.type = TYPE_NUM;  //数据类型，分数字和字符串
        n2.numbs = 1;
        n2.number[0] = rand32() % 100;
        n3.type = TYPE_NUM;
        n3.numbs = 1;
        n3.number[0] = n1.number[0] / 2 + n2.number[0] / 2;
        num[time - 1] = n3.number[0];  //利用数组记录历史值，供下面循环使用
        hour[time - 1] = time - 1;
        ui_number_update(ui_number_for_id(HIGH_NUM), &n1);  //更新需要显示的数据源
        ui_number_update(ui_number_for_id(LOW_NUM), &n2);
        ui_number_update(ui_number_for_id(AVER_NUM), &n3);
        if (n3.number[0] <= 30) {
            ui_text_set_index(ui_text_for_id(STATE), 0);    //选择图片控件的偏移,不同的“压力值”对应不同图片
        } else if (n3.number[0] > 30 && n3.number[0] <= 50) {
            ui_text_set_index(ui_text_for_id(STATE), 1);
        } else if (n3.number[0] > 50 && n3.number[0] <= 80) {
            ui_text_set_index(ui_text_for_id(STATE), 2);
        } else {
            ui_text_set_index(ui_text_for_id(STATE), 3);
        }
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = TEXT_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif
const static u8 utf8_code[] = {
    /* 希伯来语测试 */
    /* 0xD7,0xAA,0xD7,0xA8,0xD7,0x92,0xD7,0x95, 0xD7,0x9D,0x20,0xD7,0xAA,0xD7,0x9E,0xD7, 0x95,0xD7,0xA0,0xD7,0xA6,0xD7,0x9C,0xD7, 0x9D,0x20,0xD7,0x90,0xD7,0x95, */
    /*  */
    /* 0x32,0x30,0x32,0x31,0xE5,0xB9,0xB4,0x38, 0xE6,0x9C,0x88, */
    /*  */
    /* 0xD7,0x9C,0xD7,0xA9,0xD7,0x95,0xD7,0xA0, 0xD7,0x99,0xD7,0x99,0xD7,0x9D,0x20,0xD7, 0x91,0xD7,0x96,0xD7,0x9E,0xD7,0x9F,0x20, 0xD7,0x90,0xD7,0x9E,0xD7,0xAA, */
    /*  */
    /* 0xEC,0x8B,0xA4,0xEF,0xBF,0xA5,0x40,0xE5, 0x93,0x8E,0xE5,0x91,0xA6,0x68,0x61,0x6C, 0x6F,0x20,0x77,0x6F,0x72,0x6C,0x64,0xE4, 0xB8,0x8D,0xE9,0x94,0x99,0xE5,0x93,0xA6, */
    /* 0x21,0xEA,0xB0,0x84,0xEC,0x9C,0xBC,0x3E, 0x3E, */
    /*  */
    /* 0xD7,0x93,0xD7,0x99,0xD7,0x90,0xD7,0x9C, 0xD7,0x95,0xD7,0x92,0xD7,0x99,0xD7,0x9D, */
    /*  */
    /* 0xE9,0x92,0xA2,0xE9,0x93,0x81,0xE4,0xBE, 0xA0,0x20,0x49,0x72,0x6F,0x6E,0x20,0x6D, 0x61,0x6E,0x20,0xE7,0x81,0xB5,0xE7,0xAC, 0xBC,0xEB,0xB2,0x88,0xEC,0x97,0xAD,0xEC, */
    /* 0x9D,0x84,0x20,0xEC,0x96,0xBB,0xEC,0x9D, 0x84,0xE7,0x99,0xBD,0xE6,0x9C,0x88,0xE9, 0xAD,0x81, */
    /*  */
    /* 0xD7,0x9C,0xD7,0xA9,0xD7,0x95,0xD7,0xA0, 0xD7,0x99,0xD7,0x99,0xD7,0x9D,0x20,0xD7, 0x91,0xD7,0x96,0xD7,0x9E,0xD7,0x9F, */
    /*  */
    /* 0x28,0x6E,0x75,0x6D,0x31,0x35,0x36,0x38, 0x31,0x31,0x36,0x38,0x31,0x30,0x31,0x29, */
    /*  */
    /* 0xD7,0xAA,0xD7,0xA8,0xD7,0x92,0xD7,0x95, 0xD7,0x9D,0x20,0xD7,0x93,0xD7,0x99,0xD7, 0x90,0xD7,0x9C,0xD7,0x95,0xD7,0x92,0x20 */
//俄语测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xD0,0xAE, 0x20,0xD0,0xAF,0x20,0xD0,0xB0,0x20,0xD0, */
    /* 0xB1,0x20,0xD0,0xB2,0x20,0xD0,0xB3,0x20, 0xD0,0xB4,0x20,0xD0,0xB5,0x20,0xD1,0x91, 0x20,0xD0,0xB6,0x20,0xD0,0xB7,0x20,0xD0, 0xB8,0x20,0xD0,0xB9,0xE4,0xBD,0xA0,0xE5, */
    /* 0xA5,0xBD,0xE7,0x8F,0xA0,0xE6,0xB5,0xB7, 0xEF,0xBC,0x81,0x20,0xD0,0xBA,0x20,0xD0, 0xBB,0x20,0xD0,0xBC,0x20,0xD0,0xBD,0x20, 0xD0,0xBE,0x20,0xD0,0xBF,0x20,0xD1,0x80, */
    /* 0x20,0xD1,0x81,0x20,0xD1,0x82,0x20,0xD1, 0x83,0x20,0xD1,0x84,0x20,0xD1,0x85,0x20, 0xD1,0x86,0x20,0xD1,0x87,0x20,0xD1,0x88, 0x20,0xD1,0x89,0x20,0xD1,0x8A,0x20,0xD1, */
    /* 0x8B,0x20,0xD1,0x8C,0x20,0xD1,0x8D,0x20, 0xD1,0x8E,0x20,0xD1,0x8F,0x20 */
//CP1250代码页语言测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xC3,0xA4, 0x2C,0xC3,0xB6,0x2C,0xC3,0xBC,0x2C,0xC3, */
    /* 0x9F,0x2E,0xE4,0xBD,0xA0,0xE5,0xA5,0xBD, 0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF,0xBC, 0x81,0xC4,0x8C,0x20,0xCB,0x87,0x4E,0xCB, 0x87,0x20,0x4F,0x20,0x50,0x20,0x51,0x20, */
    /* 0x52,0x20,0xC5,0x98,0x20,0x53,0x20,0xC5, 0xA0,0x20,0x54,0x20,0x54,0xCB,0x87,0x20, 0x5A,0xCB,0x87,0x20,0xC4,0x87,0x2C,0x20, 0xC5,0x84,0x2C,0x20,0xC3,0xB3,0x2C,0x20, */
    /* 0xC5,0x9B,0x2C,0x20,0xC5,0xBA,0x20,0xC5, 0xBC,0x20,0xC4,0x85,0x2C,0x20,0xC4,0x99, 0x20,0xC5,0x82,0x20,0xC3,0xA1,0x2C,0x20, 0xC3,0xA9,0x2C,0x20,0xC3,0xAD,0x2C,0x20, */
    /* 0xC3,0xB3,0x2C,0xC3,0xBA,0x2C,0xC3,0xB6, 0x20,0xC5,0x91,0x20,0xC5,0xB1,0x20,0xC3, 0xBC,0x20,0xEA,0xB8,0x89,0xED,0x95,0x9C, 0xE4,0xB8,0xAD,0xE5,0x9B,0xBD,0x20 */
//CP1252代码页语言测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xC3,0xA4, 0x2C,0xC3,0xB6,0x2C,0xC3,0xBC,0x2C,0xC3, */
    /* 0x9F,0x2E,0xE4,0xBD,0xA0,0xE5,0xA5,0xBD, 0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF,0xBC, 0x81,0xC3,0xA4,0x2C,0x20,0xC3,0xAB,0x2C, 0x20,0xC3,0xAF,0x2C,0x20,0xC3,0xB6,0x20, */
    /* 0x2C,0xC3,0xBC,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0xC3,0xA1,0x2C,0x20,0xC3,0xA9,0x2C, 0xC3,0xAD,0x2C,0x20,0xC3,0xB3,0x2C,0xC3, 0xBA,0x2C,0x20,0xC3,0xBD,0x2C,0x20,0xC3, */
    /* 0xB1,0x2C,0x20,0xC3,0xAF,0x2C,0x20,0xC3, 0xBC,0x2C,0xE4,0xB8,0xAD,0xE5,0x9B,0xBD, 0x20,0xC3,0xA9,0x2C,0x20,0xC3,0xAD,0x2C, 0xC3,0xB3,0x2C,0xC3,0xBA,0x2C,0xC3,0xA0, */
    /* 0x2C,0x20,0xC3,0xA8,0x2C,0x20,0xC3,0xAC, 0x2C,0xC3,0xB2,0x2C,0xC3,0xB9,0x20,0xC3, 0xA1,0x2C,0x20,0xC3,0xA2,0x2C,0xC3,0xA3, 0x2C,0x20,0xC3,0xA0,0x2C,0x20,0xC3,0xA7, */
    /* 0x2C,0xC3,0xA9,0x2C,0xC3,0xAA,0x2C,0xC3, 0xAD,0x2C,0xC3,0xB3,0x2C,0xC3,0xB4,0x2C, 0xC3,0xB5,0x2C,0xC3,0xBA,0x2E,0xC3,0xA0, 0x2C,0x20,0xC3,0xA8,0x2C,0x20,0xC3,0xB9, */
    /* 0x2C,0x20,0xC3,0xA2,0x2C,0xC3,0xAA,0x2C, 0xC3,0xAE,0x2C,0xC3,0xB4,0x2C,0xC3,0xBB, 0x2C,0xC3,0xA9,0x2C,0xC3,0xAB,0x2C,0xC3, 0xAF,0x2C,0xC3,0xBC,0x2C,0xC3,0xBF,0xC3, */
    /* 0xA7,0x2C,0xC3,0xA6,0xC5,0x93,0x2C,0xC3, 0x85,0x2C,0xC3,0x84,0x2C,0xC3,0x96,0x2C, 0xC3,0x85,0xC3,0xA6,0xC3,0x98,0xC3,0xA9, 0xC3,0xB3,0x20 */
//泰语测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xE0,0xB9, 0x80,0xE0,0xB8,0x9B,0xE0,0xB9,0x87,0xE0, */
    /* 0xB8,0x99,0xE0,0xB8,0xA1,0xE0,0xB8,0xB9, 0xE0,0xB8,0xA5,0xE4,0xB8,0xAD,0xE5,0x9B, 0xBD,0xE0,0xB8,0x84,0xE0,0xB9,0x88,0xE0, 0xB8,0xB2,0xE0,0xB8,0x81,0xE0,0xB8,0xB2, */
    /* 0xE0,0xB8,0xA3,0xE0,0xB8,0x81,0xE0,0xB8, 0xA5,0xE0,0xB9,0x88,0xE0,0xB8,0xB2,0xE0, 0xB8,0xA7,0xE0,0xB8,0x82,0xE0,0xB8,0xA7, 0xE0,0xB8,0xB1,0xE0,0xB8,0x8D,0xE0,0xB8, */
    /* 0xA7,0xE0,0xB9,0x88,0xE0,0xB8,0xB2,0xE0, 0xB9,0x83,0xE0,0xB8,0x99,0xE0,0xB8,0x9A, 0xE0,0xB8,0xA3,0xE4,0xBD,0xA0,0xE5,0xA5, 0xBD,0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF, */
    /* 0xBC,0x81,0xE0,0xB8,0xA3,0xE0,0xB8,0x94, 0xE0,0xB8,0xB2,0xE0,0xB8,0xAB,0xE0,0xB9, 0x89,0xE0,0xB8,0xB2,0xE0,0xB8,0x9B,0xE0, 0xB8,0xA3,0xE0,0xB8,0xB0,0xE0,0xB9,0x80, */
    /* 0xE0,0xB8,0x97,0xE0,0xB8,0xA8,0xE0,0xB8, 0x99,0xE0,0xB8,0xAD,0xEA,0xB8,0x89,0xED, 0x95,0x9C,0x20 */
//越南语测试编码
    /* 0x54, 0x68, 0xE1, 0xBB, 0x8B, 0x20, 0x74, 0x72, 0xE1, 0xBA, 0xA5, 0x6E, 0x20, 0xE6, 0x88, 0x91, 0xE6, 0x98, 0xAF, 0xE4, 0xB8, 0x80, 0xE4, 0xB8, 0xAA, 0xE6, 0x88, 0x98, 0xE5, 0xA3, 0xAB, 0x2C, */
    /* 0x45, 0x6E, 0x67, 0x6C, 0x69, 0x73, 0x68, 0x20, 0xEC, 0x93, 0xB0, 0xEC, 0xB4, 0xA8, 0xEC, 0x84, 0xB1, 0x20, 0x3E, 0x3E, 0x20, 0x53, 0x68, 0x75, 0x69, 0x6E, 0x61, 0x6E, 0x2C, 0x20, 0xE7, 0x99, */
    /* 0xBD, 0xE6, 0x9C, 0x88, 0xE9, 0xAD, 0x81, 0x20, 0x68, 0x75, 0x79, 0xE1, 0xBB, 0x87, 0x6E, 0x20, 0xEB, 0x84, 0xA4, 0xEC, 0x9D, 0xB4, 0xEC, 0x9E, 0xA5, 0x20, 0xE4, 0xBA, 0x91, 0xE6, 0x9B, 0xA6, */
    /* 0x2C, 0x20, 0x49, 0x20, 0x61, 0x6D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x61, 0x74, 0x68, 0x20, 0xE6, 0x80, 0x95, 0xE7, 0x9A, */
    /* 0x84, 0xE4, 0xB8, 0x8D, 0xE6, 0x98, 0xAF, 0xE6, 0xAD, 0xBB, 0x2A, 0x2A, 0x25, 0xEF, 0xBF, 0xA5, 0x40, 0xEF, 0xBC, 0x8C, 0x74, 0x68, 0xC3, 0xA0, 0x6E, 0x68, 0x20, 0xE7, 0x81, 0xB5, 0xE7, 0xAC, */
    /* 0xBC, 0x20, 0x70, 0x68, 0xE1, 0xBB, 0x91, 0x58, 0x75, 0x79, 0xC3, 0xAA, 0x6E, 0x20, 0x54, 0xC3, 0xA2, 0x6E, 0x20, 0xE8, 0x80, 0x8C, 0xE6, 0x98, 0xAF, 0xE6, 0xB2, 0xA1, 0xE6, 0x9C, 0x89, 0xEC, */
    /* 0xA4, 0x91, 0xED, 0x98, 0x84, 0x20, 0xEC, 0x8A, 0x88, 0xEC, 0x9D, 0xB4, 0xEB, 0x82, 0x9C, 0xEC, 0xA7, 0x84, 0xE7, 0x9C, 0x9F, 0xE6, 0xAD, 0xA3, 0xE7, 0x9A, 0x84, 0xE6, 0xB4, 0xBB, 0xE8, 0xBF, */
    /* 0x87, 0x20, 0x47, 0x69, 0x61, 0x6E, 0x67, 0x2C, 0x20, 0x74, 0xE1, 0xBB, 0x89, 0x6E, 0x68, 0x20, 0xE7, 0xBA, 0xA2, 0xE5, 0xAF, 0x87, 0x20, 0x54, 0xE1, 0xBB, 0xA9, 0x20, 0x45, 0x6E, 0x67, 0x6C, */
    /* 0x69, 0x73, 0x68, 0x20, 0x58, 0x75, 0x79, 0xC3, 0xAA, 0x6E, 0x20 */
//阿拉伯语测试编码
    0xD8, 0xA3, 0xD9, 0x86, 0xD8, 0xA7, 0x20, 0xD9, 0x85, 0xD9, 0x82, 0xD8, 0xA7, 0xD8, 0xAA, 0xD9, 0x84, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x88, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE,
    0xD8, 0xA7, 0xD8, 0xA6, 0xD9, 0x81, 0xD9, 0x8B, 0xD8, 0xA7,

    0xE6, 0x88, 0x91, 0xE6, 0x98, 0xAF, 0xE4, 0xB8, 0x80, 0xE4, 0xB8, 0xAA, 0xE6, 0x88, 0x98, 0xE5, 0xA3, 0xAB, 0x3C, 0x49, 0x4E, 0x43, 0x41, 0x52, 0x4E, 0x41, 0x54, 0x49, 0x4F, 0x4E, 0x3E, 0xEB,
    0x91, 0x90, 0xEB, 0xA0, 0xA4, 0xEC, 0x9B, 0x8C, 0xED, 0x95, 0x98, 0xEC, 0xA7, 0x80, 0xEC, 0x95, 0x8A, 0xEC, 0xA7, 0x80,

    0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A, 0xEC, 0xA0, 0x84, 0xEC, 0x82, 0xAC, 0xEC, 0x9D, 0xB4, 0xEA, 0xB3, 0xA0, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA,

    0xE6, 0x80, 0x95, 0xE7, 0x9A, 0x84, 0x28, 0x25, 0x25, 0x46, 0x61, 0x6B, 0x65, 0x26, 0x26, 0x29, 0xE4, 0xB8, 0x8D, 0xE6, 0x98, 0xAF, 0xE6, 0xAD, 0xBB, 0xEF, 0xBC, 0x8C, 0xE8, 0x80, 0x8C, 0xE6,
    0x98, 0xAF, 0xE6, 0xB2, 0xA1, 0xE6, 0x9C, 0x89,

    0x49, 0x20, 0x61, 0x6D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6E, 0x6F,
    0x74, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x6C, 0x69, 0x76, 0x69, 0x6E, 0x67, 0x2E,

    0xD9, 0x85, 0xD9, 0x86, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0xD9, 0x88, 0xD8, 0xAA, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A,

    0xE7, 0x9C, 0x9F, 0xE6, 0xAD, 0xA3, 0xE7, 0x9A, 0x84, 0xEB, 0x8B, 0x99, 0xEB, 0x8B, 0x88, 0xEB, 0x8B, 0xA4, 0xE6, 0xB4, 0xBB, 0xE8, 0xBF, 0x87, 0xEF, 0xBC, 0x81,

    0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE, 0xD8, 0xA7, 0xD8, 0xA6, 0xD9, 0x81, 0xD9, 0x8B, 0xD8, 0xA7, 0x20, 0xD9, 0x85, 0xD9, 0x86, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0xD9,
    0x88, 0xD8, 0xAA, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A, 0x20, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE, 0xD8, 0xA7, 0xD8, 0xA6, 0xD9,
    0x81, 0xD9, 0x8B, 0xD8, 0xA7, 0x20, 0xD8, 0xAD, 0xD9, 0x82, 0xD9, 0x8B, 0xD8, 0xA7, 0x2E, 0x20
};

static int TEXT_TEST_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct ui_text *text = (struct ui_text *)ctr;
    //int language;
    switch (e) {
    case ON_CHANGE_INIT:
        ui_language_set(Arabic);
        /* 当前显示不同语言只需设置语言地区及更换字符编码即可 */
        /* ui_language_set(Polish);  //设置当前待显示字符的地区，共用1252的用Danish，1250的用Polish */
        //language = ui_language_get();
        ui_text_set_text_attrs(text, (char *)utf8_code, sizeof(utf8_code), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = TEXT_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


#if 0
static int text_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    static u8 *name_p = "liangweixin@jh-jieli.com";
    /* static u8 *name_p = "lian"; */

    switch (event) {
    case ON_CHANGE_INIT:
        ui_text_set_text_attrs(text, name_p, strlen(name_p), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = text_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif


#if 1
static int ascii_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        ui_text_set_str(text, "ascii", "liangweixin", strlen("liangweixin"), FONT_DEFAULT);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(ASCII_TEST)
.onchange = ascii_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

/*文本控件多字符串组合显示示例*/
static int mulstr_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    u8 index_buf[7] ALIGNED(4);
    static u16 store_buf[7 * 2 + 2] ALIGNED(4);

    switch (event) {
    case ON_CHANGE_INIT:
        /* 一二三四五六日 */
        index_buf[0] = 0;//一
        index_buf[1] = 1;//二
        index_buf[2] = 2;//三
        index_buf[3] = 3;//四
        index_buf[4] = 4;//五
        index_buf[5] = 5;//六
        index_buf[6] = 6;//日
        ui_text_set_combine_index(text, store_buf, index_buf, 7);
        /* store_buf[0] = 216; */
        /* store_buf[1] = 217; */
        /* store_buf[2] = 218; */
        /* store_buf[3] = 219; */
        /* store_buf[4] = 220; */
        /* store_buf[5] = 221; */
        /* store_buf[6] = 222; */
        for (u8 i = 0; i < sizeof(store_buf); i++) {
            y_printf("store_buf[%d]:%d", i, store_buf[i]);
        }
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(MULSTR_TEST)
.onchange = mulstr_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

void NUM_TEST_timer(void *priv)
{
    if (!watch_num_test_timer) {
        return ;
    }
    struct unumber n;
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = rand32();
    ui_number_update_by_id(NUM_TEST, &n);
}

static int NUM_TEST_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_ctrl;
    struct unumber n;
    switch (event) {
    case ON_CHANGE_INIT:
        n.type = TYPE_NUM;
        n.numbs = 1;
        n.number[0] = rand32();
        ui_number_update(number, &n);
        if (!watch_num_test_timer) {
            watch_num_test_timer = sys_timer_add(NULL, NUM_TEST_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_test_timer) {
            sys_timer_del(watch_num_test_timer);
            watch_num_test_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(NUM_TEST)
.onchange = NUM_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


#if OLDER_STYLE

static void NUM_1_timer(void *priv)
{
    struct unumber n = {0};
    static int steps = 0;
    if (!watch_num_1_timer) {
        return ;
    }

    steps++;
    if (steps > 1000) {
        steps = 0;
    }

    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = steps;
    ui_number_update_by_id(PRESSURE_NUM_1, &n);
}


static int NUM_1_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.steps = 0;
        number->nums = 1;
        number->number[0] = progress_record.steps;

        if (!watch_num_1_timer) {
            watch_num_1_timer = sys_timer_add(NULL, NUM_1_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_1_timer) {
            sys_timer_del(watch_num_1_timer);
            watch_num_1_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_1)
.onchange = NUM_1_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static void NUM_2_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_2_timer) {
        return;
    }
    this->min++;
    if (this->min > 30) {
        this->min = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 2;
    n.number[0] = this->min;
    n.number[1] = this->target_min;
    ui_number_update_by_id(PRESSURE_NUM_2, &n);
    percent = this->min * 100 / this->target_min;
}

static int NUM_2_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.min = 0;
        progress_record.target_min = 30;
        number->nums = 2;
        number->number[0] = progress_record.min;
        number->number[1] = progress_record.target_min;
        if (!watch_num_2_timer) {
            watch_num_2_timer = sys_timer_add(&progress_record, NUM_2_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_2_timer) {
            sys_timer_del(watch_num_2_timer);
            watch_num_2_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_2)
.onchange = NUM_2_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};



static void NUM_3_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_3_timer) {
        return ;
    }
    this->times++;
    if (this->times > 12) {
        this->times = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 2;
    n.number[0] = this->times;
    n.number[1] = this->target_times;
    ui_number_update_by_id(PRESSURE_NUM_3, &n);
    percent = this->times * 100 / this->target_times;
}

static int NUM_3_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.times = 0;
        progress_record.target_times = 12;
        number->nums = 2;
        number->number[0] = progress_record.times;
        number->number[1] = progress_record.target_times;
        if (!watch_num_3_timer) {
            watch_num_3_timer = sys_timer_add(&progress_record, NUM_3_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_3_timer) {
            sys_timer_del(watch_num_3_timer);
            watch_num_3_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_3)
.onchange = NUM_3_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif

static void BT_COMPASS_timer(void *priv)
{
    if (!watch_bt_compass_timer) {
        return;
    }
    static int bk_angle = 0;
    static int ind_angle = 0;
    int sign = rand32() % 2;

    bk_angle = sign ? 360 - (rand32() % 180) : rand32() % 180;

    ui_io_set(IO_FRAME, HIGH);
    ui_compass_set_angle_by_id(BT_COMPASS, bk_angle, ind_angle);
    ui_io_set(IO_FRAME, LOW);

    /* bk_angle += 6; */
    /* if (bk_angle >= 360) { */
    /* bk_angle = 0; */
    /* } */
}

static int BT_COMPASS_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_compass *compass = (struct ui_compass *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        if (!watch_bt_compass_timer) {
            watch_bt_compass_timer = sys_timer_add(NULL, BT_COMPASS_timer, 100);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_bt_compass_timer) {
            sys_timer_del(watch_bt_compass_timer);
            watch_bt_compass_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(BT_COMPASS)
.onchange = BT_COMPASS_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif

static int pic_sys_reboot_and_shutdown_ontouch(void *_ctrl, struct element_touch_event *e)
{
    static u8 touch_action = 0;
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:
        if (touch_action != 1) {
            break;
        }
        switch (pic->elm.id) {
        case PIC_SYS_REBOOT:
            extern int lcd_drv_power_ctrl(u8 on);
            lcd_drv_power_ctrl(false);
            watch_reboot_or_shutdown(1, 0);
            break;
        case PIC_SYS_SHUTDOWN:
            watch_reboot_or_shutdown(0, 0);
            break;
        }
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        return true;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    }
    return false;
}
REGISTER_UI_EVENT_HANDLER(PIC_SYS_REBOOT)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = pic_sys_reboot_and_shutdown_ontouch,
};
REGISTER_UI_EVENT_HANDLER(PIC_SYS_SHUTDOWN)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = pic_sys_reboot_and_shutdown_ontouch,
};

#endif
#endif /* #if (!TCFG_LUA_ENABLE) */


