RGBA -> ARGB(4dpi对齐) -> ARGB（保留1，非压缩）
	保留1 + ARGB ->ARGB_IMB

RGB565->(2dpi对齐) (原文件,SWAP，非压缩)
	RGB_IMB

IMB格式(保留1，压缩资源)





BMP\SJPG\JPG\PNG:
	需要走单独解码器


IMB压缩工具：
原图 -> .dat

打包(加HEAD头)：
.bin	->	.bin
.dat	->	.bin
.bmp/sjpg/jpg/bmp	->	.bin

宏定义头：
FILE_NAME_BIN	0x123
FILE_TEST_SJPG	0x456
FILE_TEST_IMB	0x789

每个文件的名字对应表，排序+二分法：
{"name.bin", 0x123}，
{"name.bin", 0x123}，
{"name.bin", 0x123}，
{"name.bin", 0x123}，



文件结构：
1.LVGL图像-> 		LV_HEAD + DATA						(CF==LV_IMG_CF_TRUE_COLOR ~ LV_IMG_CF_RGB565A8) 
2.IMB压缩图像->   		LV_HEAD + "_IMB" + FILEINFO + DATA（IMB头识别） 		(CF==LV_IMG_CF_RAW ~ LV_IMG_CF_RAW_CHROMA_KEYED)
3.BMP\SJPG\JPG\PNG -> 	LV_HEAD + DAT（每个标准文件都有特定的头识别）		(CF==LV_IMG_CF_RAW ~ LV_IMG_CF_RAW_CHROMA_KEYED)


解bin数据：
	(CF==LV_IMG_CF_TRUE_COLOR~LV_IMG_CF_RGB565A8)
		LVGL原始文件 -> w\h\addr\cf
	(CF==LV_IMG_CF_RAW)
		IMB文件  -> 读头匹配解码器 -> w\h\addr\cf

创建 lv_img_dsc_t
	ui_test.header.reserved = 0；
	ui_test.header.cf = LV_IMG_CF_TRUE_COLOR;//LV_IMG_CF_TRUE_COLOR_ALPHA;/RAWDATA
    	ui_test.header.w = 397;//240;
    	ui_test.header.h = 213;//240;
    	ui_test.data_size = ui_test.header.w*ui_test.header.h*2;
    	ui_test.data = 0x4000000+0xe00000 + 4;


draw_img(CF==LV_IMG_CF_RAW || CF==LV_IMG_CF_RAW_ALA)
	判断data若是"_IMB"或JPG头（IMB、JPG），走对应的硬件解码器解码
	否则返回INV给下一个解码器

decode_and_draw
	_lv_img_cache_open
		lv_img_decoder_open
			info_cb：获给取图片信息给LV的&dsc->header，以确定原图coords绘制区域
			open_cb：打开解码器：
				若是解压数据：dec_dsc.img_data给数据指针
				若是非解压数据：dec_dsc.img_data = NULL

	解压数据（cdsc->dec_dsc.img_data有值）
		lv_draw_img_decoded：进行区域合成

	非解压数据（cdsc->dec_dsc.img_data == NULL）
		read_line_cb:逐行解码（引用对应格式的软件解码器）
		lv_draw_img_decoded：逐行区域合成
